//@version=6
indicator("Unified Trading Command Center v2.5.0 - Institutional", 
     shorttitle="Forex", 
     overlay=true, 
     max_labels_count=100,
     max_lines_count=100)

// ============================================================================
// UNIFIED TRADING COMMAND CENTER v2.5.0 - INSTITUTIONAL
// ============================================================================
// Asset Class: FX (Forex)
// Version: 2.5.0 - Institutional Compliance Refactor
//
// v2.5.0 CHANGES (Institutional Audit Compliance):
// - 4-Emoji Standard: Green/Yellow/Red/White circle only
// - Alert types: ARMED / CANDIDATE / BLOCKED / INFO (no DISARMED/RESET)
// - Reason-code taxonomy: R-series (regime), K-series (risk), U-series (UTCC)
// - Priority Resolver: Regime > Risk > UTCC authority stack
// - Risk Governor input: NORMAL / REDUCED / LOCKED (from Command Centre)
// - Two-layer alert format: Scan line + JSON audit body
// - f_buildAlert() replaces buildJsonPayload() and buildDetailMsg()
// - Display panel: institutional status (Phase 2)
//
// CRITICAL: 5-criteria logic, scoring weights, session lock mechanics,
// ATR hierarchy detection, and MTF calculations are UNCHANGED.
// ============================================================================

// ============================================================================
// INPUTS - DISPLAY SETTINGS
// ============================================================================
GRP_DISPLAY = "Display Settings"
displayMode = input.string("Compact", "Display Mode", 
     options=["Minimal", "Compact", "Standard", "Full"], 
     group=GRP_DISPLAY,
     tooltip="Minimal=Status only | Compact=Status+Checklist | Standard=+Key details | Full=Everything")
panelPosition = input.string("Top Right", "Panel Position", 
     options=["Top Left", "Top Right", "Bottom Left", "Bottom Right"], 
     group=GRP_DISPLAY)
panelSize = input.string("Medium", "Panel Size", 
     options=["Small", "Medium", "Large"], 
     group=GRP_DISPLAY)

// ============================================================================
// INPUTS - VISUAL CUSTOMIZATION (FULL CONTROL)
// ============================================================================
GRP_VISUAL = "Visual Customisation"

// Font Sizes - Complete Control
headerFontSize = input.string("Normal", "Header Font Size", 
     options=["Tiny", "Small", "Normal", "Large", "Huge"], 
     group=GRP_VISUAL,
     tooltip="Section headers (CRITERIA CHECKLIST, SCORE BREAKDOWN)")
statusFontSize = input.string("Large", "Status Font Size", 
     options=["Tiny", "Small", "Normal", "Large", "Huge"], 
     group=GRP_VISUAL,
     tooltip="Alert type (ARMED / CANDIDATE / BLOCKED / INFO)")
dataFontSize = input.string("Small", "Data Font Size", 
     options=["Tiny", "Small", "Normal", "Large", "Huge"], 
     group=GRP_VISUAL,
     tooltip="Criteria labels and values")
scoreFontSize = input.string("Normal", "Score Font Size", 
     options=["Tiny", "Small", "Normal", "Large", "Huge"], 
     group=GRP_VISUAL,
     tooltip="Score displays and numbers")

// Table Structure
borderWidth = input.int(1, "Border Width", minval=0, maxval=10,
     group=GRP_VISUAL,
     tooltip="Thickness of lines between cells (0 = no borders)")
frameWidth = input.int(2, "Frame Width", minval=0, maxval=10,
     group=GRP_VISUAL,
     tooltip="Thickness of outer table frame")

// Transparency Controls
panelTransparency = input.int(0, "Background Transparency", minval=0, maxval=100,
     group=GRP_VISUAL,
     tooltip="Table background opacity (0 = solid, 100 = invisible)")
borderTransparency = input.int(0, "Border Transparency", minval=0, maxval=100,
     group=GRP_VISUAL,
     tooltip="Border and frame opacity (0 = solid, 100 = invisible)")

// === ALERT DEBUG MODE ===
debugMode = input.bool(false, "Force Test Alerts", tooltip="Enable to force all alerts to fire on next bar close. Use for testing alert delivery. DISABLE after testing!")
showAlertDiagnostics = input.bool(false, "Alert Diagnostics Panel", tooltip="Shows real-time status of each alert condition - see exactly what's blocking alerts from firing")

// ============================================================================
// INPUTS - CRITERIA THRESHOLDS (YOUR 5 RULES)
// ============================================================================
GRP_CRITERIA = "4-Criteria Thresholds"

// Criterion 1: Trend Score
minTrendScore = input.int(80, "1. Min Trend Score", minval=60, maxval=100, 
     group=GRP_CRITERIA,
     tooltip="Minimum trend strength required (80 recommended)")

// Criterion 2: MTF Alignment (always 3/3 required)

// Criterion 3: Volatility Ready
acceptTrend = input.bool(true, "3. Accept: TREND", group=GRP_CRITERIA, inline="vol1")
acceptExplode = input.bool(true, "EXPLODE (with rules)", group=GRP_CRITERIA, inline="vol1")
explodeMinPercentile = input.int(20, "EXPLODE Min %ile", minval=0, maxval=100, group=GRP_CRITERIA, inline="vol2")
explodeMaxPercentile = input.int(80, "EXPLODE Max %ile", minval=0, maxval=100, group=GRP_CRITERIA, inline="vol2")
acceptQuiet = input.bool(true, "Accept: QUIET (with rules)", group=GRP_CRITERIA, inline="vol3")
quietMinPercentile = input.int(30, "QUIET Min %ile", minval=0, maxval=100, group=GRP_CRITERIA, inline="vol4")
quietMaxPercentile = input.int(70, "QUIET Max %ile", minval=0, maxval=100, group=GRP_CRITERIA, inline="vol4")

// Criterion 4: ATR Filter (Now Adjustable!)
atrFilterPercent = input.int(80, "4. ATR Filter Threshold %", 
     minval=0, maxval=150, step=5,
     group=GRP_CRITERIA,
     tooltip="ATR must exceed X% of its 50-bar average.\n\n‚Ä¢ 0% = Disabled (no filtering) ‚Üê Gave you 8-15 alerts/candle\n‚Ä¢ 80% = Soft ‚Üê RECOMMENDED START\n‚Ä¢ 100% = Standard (balanced)\n‚Ä¢ 120% = Strict (original default) ‚Üê Was blocking most alerts\n‚Ä¢ 150% = Very Strict (rare signals only)\n\nYour previous ON/OFF toggle was 120%. Start at 80% and adjust from there.")

// Criterion 5: News Status
newsBufferHours = input.int(2, "5. News Buffer (hours)", minval=0, maxval=8, 
     group=GRP_CRITERIA,
     tooltip="Block trades X hours before high-impact news")
blockHighImpact = input.bool(true, "Block High Impact", group=GRP_CRITERIA, inline="news")
blockMedImpact = input.bool(false, "Block Medium Impact", group=GRP_CRITERIA, inline="news")

// ============================================================================
// INPUTS - EXECUTION CONTEXT (NEW DAY 2)
// ============================================================================
GRP_CONTEXT = "Execution Context"

// Session Settings
showSessionInfo = input.bool(true, "Show Session Indicator", 
     group=GRP_CONTEXT,
     tooltip="Display current trading session with volatility hints (Tokyo/London/NY/LON+NY)")

// Timer Settings
showBarTimer = input.bool(true, "Show Time to Bar Close", 
     group=GRP_CONTEXT,
     tooltip="Warn when bar is about to close (prevents late entries)")
barTimerCritical = input.int(5, "Critical Warning (min)", minval=1, maxval=30, 
     group=GRP_CONTEXT,
     tooltip="RED alert - Bar closing very soon! Avoid new entries")
barTimerWarning = input.int(15, "Warning (min)", minval=1, maxval=60, 
     group=GRP_CONTEXT,
     tooltip="YELLOW alert - Bar closing soon, be cautious")
barTimerCaution = input.int(30, "Caution (min)", minval=1, maxval=120, 
     group=GRP_CONTEXT,
     tooltip="ORANGE alert - Bar closing in moderate time")

// Spread Settings
showSpreadMonitor = input.bool(true, "Show Spread Monitor", 
     group=GRP_CONTEXT,
     tooltip="Track spread vs average (execution quality)")
spreadWarningMultiplier = input.float(1.5, "Spread Warning Multiplier", minval=1.0, maxval=3.0, step=0.1,
     group=GRP_CONTEXT,
     tooltip="Warn when spread exceeds X times recent average")

// ============================================================================
// INPUTS - SCORING SYSTEM
// ============================================================================
GRP_SCORE = "Scoring System"
minTradeScore = input.int(75, "Min Score for TRADE", minval=60, maxval=95, 
     group=GRP_SCORE,
     tooltip="75=Balanced | 80=Strict | 70=Aggressive")
minCautionScore = input.int(65, "Min Score for CAUTION", minval=50, maxval=80, 
     group=GRP_SCORE,
     tooltip="65=Balanced | 70=Strict | 60=Aggressive")

// ============================================================================
// INPUTS - EMA TREND SETTINGS
// ============================================================================
GRP_TREND = "Trend Settings"
fastLength = input.int(9, "Fast EMA", minval=1, group=GRP_TREND)
midLength = input.int(21, "Mid EMA", minval=1, group=GRP_TREND)
slowLength = input.int(50, "Slow EMA", minval=1, group=GRP_TREND)
trendLength = input.int(200, "HTF Trend EMA", minval=1, group=GRP_TREND)
adxLength = input.int(14, "ADX Length", minval=1, group=GRP_TREND)
adxThreshold = input.int(20, "ADX Threshold", minval=10, maxval=50, group=GRP_TREND)

// MTF Settings
mtf1 = input.timeframe("60", "MTF 1", group=GRP_TREND)
mtf2 = input.timeframe("240", "MTF 2", group=GRP_TREND)
mtf3 = input.timeframe("D", "MTF 3", group=GRP_TREND)

// ============================================================================
// INPUTS - ATR VOLATILITY SETTINGS
// ============================================================================
GRP_ATR = "Volatility Settings"
atrLength = input.int(14, "ATR Length", minval=1, group=GRP_ATR)
atrPercentileLookback = input.int(252, "ATR Percentile Lookback", minval=50, maxval=1000, group=GRP_ATR)

// ATR State Settings (for hierarchy detection)
atrBaseline = input.int(50, "ATR Baseline Length", minval=10, maxval=200, group=GRP_ATR)
sepTolerance = input.float(0.20, "Separation Tolerance", minval=0.01, maxval=0.50, step=0.01, group=GRP_ATR)
eqTolerance = input.float(0.40, "Equality Tolerance", minval=0.05, maxval=0.50, step=0.01, group=GRP_ATR)

// ============================================================================
// INPUTS - ALERT SETTINGS (v1.6 STREAMLINED)
// ============================================================================
GRP_ALERTS = "Context Alerts"

// Alert Mode Selection
alertMode = input.string("alertcondition", "Alert Mode",
     options=["alertcondition", "alert() per bar", "alert() bar close"],
     group=GRP_ALERTS,
     tooltip="alertcondition = Use TradingView trigger options (Once per minute)\nalert() per bar = Mid-bar via Any alert() function call\nalert() bar close = Bar close via Any alert() function call")

// STATE CHANGE ALERTS ONLY - No scores, no hype, just context
enableContextCandidate = input.bool(true, "CONTEXT CANDIDATE Alert",
     group=GRP_ALERTS,
     tooltip="Elite early heads-up (intra-bar). Tighter than ARMED. Not permission to trade - just watch and prepare.")
enableContextArmed = input.bool(true, "CONTEXT ARMED Alert", 
     group=GRP_ALERTS,
     tooltip="Fires when context becomes valid for trading. Permission to observe, not act.")
enableContextDisarmed = input.bool(true, "CONTEXT DISARMED Alert", 
     group=GRP_ALERTS,
     tooltip="Fires when dual disarm triggers. Stop hunting. Cancel bias. More important than armed.")
enableSessionReset = input.bool(true, "SESSION RESET Alert", 
     group=GRP_ALERTS,
     tooltip="Fires when new session begins. Fresh evaluation required. Don't trade yesterday's logic.")

// Thresholds
alertStrongThreshold = input.int(80, "ARMED Threshold", 
     minval=70, maxval=90, group=GRP_ALERTS,
     tooltip="Score required for context to ARM. Permission gate.")
candidateThreshold = input.int(85, "CANDIDATE Threshold",
     minval=70, maxval=95, group=GRP_ALERTS,
     tooltip="Score required for CANDIDATE. Set higher than ARMED to keep it elite (recommended: 85).")

// Internal constant for diagnostic display (not used in alerts anymore)
alertPerfectThreshold = 85

// ============================================================================
// INPUTS - SESSION LOCK (v1.8 INSTITUTIONAL)
// ============================================================================
GRP_LOCK = "Session Lock"

enableSessionLock = input.bool(true, "Enable Session Lock",
     group=GRP_LOCK,
     tooltip="Lock regime at session open. Prevents mid-session bias changes from noise.")

disarmScoreThreshold = input.int(10, "Disarm Score Drop",
     minval=5, maxval=20, step=1,
     group=GRP_LOCK,
     tooltip="Score must drop X points below armed level to BEGIN disarm process.\nDisarm also requires structural damage (MTF break, efficiency collapse, or EMA compression).")

efficiencyThreshold = input.float(0.4, "Min Directional Efficiency",
     minval=0.1, maxval=0.8, step=0.05,
     group=GRP_LOCK,
     tooltip="Body/Range ratio. Below this = structural damage.\n0.7+ = Strong directional\n0.4-0.7 = Mixed\n<0.4 = Indecision (wick-heavy)")

upgradePersistence = input.int(2, "Upgrade Persistence (bars)",
     minval=1, maxval=5,
     group=GRP_LOCK,
     tooltip="Score must stay above threshold for X bars before arming.\nDowngrades are immediate on structural damage.")
// (A+ and MTF thresholds removed - alerts are now state-based only)
mtfDegradationScoreThreshold = input.int(75, "4H Score Warning Level", 
     minval=60, maxval=85, group=GRP_ALERTS,
     tooltip="Alert when score drops below this")

// ============================================================================
// INPUTS - RISK GOVERNOR (from Command Centre state)
// ============================================================================
GRP_RISK_GOV = "Risk Governor"
riskGovernorState = input.string("NORMAL", "Risk State",
     options=["NORMAL", "REDUCED", "LOCKED"],
     group=GRP_RISK_GOV,
     tooltip="Set from Command Centre.\nNORMAL: Full trading\nREDUCED: -3% drawdown or 2+ consecutive losses\nLOCKED: -5% drawdown or circuit breaker")

// Entry Zone
strongEntryRequirement = input.string("HOT/OPTIMAL", "Entry Zone for A Alerts", 
     options=["HOT/OPTIMAL", "Include ACCEPTABLE", "Any Zone"],
     group=GRP_ALERTS)

// Risk Settings
riskSpreadMultiplier = input.float(2.0, "Spread Spike Threshold", 
     minval=1.5, maxval=5.0, step=0.5, group=GRP_ALERTS)

// ============================================================================
// ALERT MESSAGE CONTENT (for detailed alert() function)
// ============================================================================
GRP_MSG = "Alert Message Content"
msgShowPair = input.bool(true, "Show Pair", group=GRP_MSG, inline="msg1")
msgShowScore = input.bool(true, "Show Score", group=GRP_MSG, inline="msg1")
msgShowTrend = input.bool(true, "Show Trend Score", group=GRP_MSG, inline="msg1")
msgShowEntry = input.bool(true, "Show Entry Zone", group=GRP_MSG, inline="msg2")
msgShowMTF = input.bool(true, "Show MTF Count", group=GRP_MSG, inline="msg2")
msgShowRSI = input.bool(true, "Show RSI Count", group=GRP_MSG, inline="msg2")
msgShowATR = input.bool(false, "Show ATR State", group=GRP_MSG, inline="msg3")
msgShowSession = input.bool(false, "Show Session", group=GRP_MSG, inline="msg3")
msgShowTimeframe = input.bool(false, "Show Timeframe", group=GRP_MSG, inline="msg3")

// ============================================================================
// INPUTS - ALERT QUALITY FILTERS (NEW v1.5 - Fine-tune your signals!)
// ============================================================================
GRP_FILTERS = "Alert Quality Filters"

// S/R Proximity Filter
srProximityFilter = input.float(0.0, "Min S/R Distance (ATR)", 
     minval=0.0, maxval=3.0, step=0.1,
     group=GRP_FILTERS,
     tooltip="Block alerts when price is within X ATR of support/resistance.\n\n‚Ä¢ 0.0 = Disabled ‚Üê PREVIOUS BEHAVIOUR (no S/R filter)\n‚Ä¢ 0.5 = Moderate (avoid obvious S/R)\n‚Ä¢ 1.0 = Strict (clear air only)\n\nNEW FILTER: Start at 0, increase if trades keep hitting S/R quickly.")

// Score Gap Requirement
scoreGapRequired = input.int(0, "Score Gap Above Threshold",
     minval=0, maxval=20, step=1,
     group=GRP_FILTERS,
     tooltip="Require score to exceed threshold by X points.\n\n‚Ä¢ 0 = Disabled ‚Üê PREVIOUS BEHAVIOUR\n‚Ä¢ 5 = Moderate buffer (score 80 needs 85 to alert)\n‚Ä¢ 10 = Conservative buffer\n\nNEW FILTER: Start at 0, increase if you want higher quality only.")

// ATR Percentile Floor
atrPercentileFloor = input.int(0, "Min ATR Percentile",
     minval=0, maxval=50, step=5,
     group=GRP_FILTERS,
     tooltip="Only alert when ATR percentile is above this floor.\n\n‚Ä¢ 0 = Disabled ‚Üê PREVIOUS BEHAVIOUR\n‚Ä¢ 10 = Filter dead markets\n‚Ä¢ 20 = Moderate activity required\n‚Ä¢ 30 = Active markets only\n\nNEW FILTER: Start at 0, increase to avoid choppy conditions.")

// ============================================================================
// INPUTS - RSI MOMENTUM SETTINGS
// ============================================================================
GRP_RSI = "Momentum Settings"
rsiLength = input.int(14, "RSI Length", minval=1, group=GRP_RSI)
rsiOverbought = input.int(70, "RSI Overbought", minval=50, maxval=90, group=GRP_RSI)
rsiOversold = input.int(30, "RSI Oversold", minval=10, maxval=50, group=GRP_RSI)

// ============================================================================
// INPUTS - STYLE CUSTOMIZATION
// ============================================================================
GRP_STYLE = "Colours & Style"

// Status colors
colorTradeGreen = input.color(color.rgb(0, 200, 0), "Trade Ready", group=GRP_STYLE, inline="status1")
colorCautionOrange = input.color(color.rgb(255, 165, 0), "Caution", group=GRP_STYLE, inline="status2")
colorNoTradeRed = input.color(color.rgb(220, 20, 20), "No Trade", group=GRP_STYLE, inline="status3")

// Criteria colors
colorPass = input.color(color.rgb(34, 171, 148), "Pass", group=GRP_STYLE, inline="crit1")
colorFail = input.color(color.rgb(239, 83, 80), "Fail", group=GRP_STYLE, inline="crit2")

// Table colors
colorHeader = input.color(color.rgb(64, 115, 122), "Header BG", group=GRP_STYLE, inline="table1")
colorBody = input.color(color.rgb(45, 52, 58), "Body BG", group=GRP_STYLE, inline="table2")
colorText = input.color(color.white, "Text", group=GRP_STYLE, inline="table3")

// ============================================================================
// CALCULATIONS: EMA TREND SYSTEM
// ============================================================================

// ============================================================================
// INSTITUTIONAL ALERT BUILDER (v2.5.0)
// ============================================================================
// 4-Emoji Standard: Exactly one emoji per alert type. No variations.
// Reason-Code Taxonomy: R-series (regime), K-series (risk), U-series (UTCC)
// Two-layer format: Scan line (triage) + Body (audit detail)
// ============================================================================

// --- Alert Type Constants ---
ALERT_INFO      = "INFO"
ALERT_CANDIDATE = "CANDIDATE"
ALERT_ARMED     = "ARMED"
ALERT_BLOCKED   = "BLOCKED"

// --- Execution Constraint Strings ---
EXECUTION_NONE = "NONE"

EXECUTION_FULL = "- MAX_RISK: 1.0R\n" +
     "- MAX_TRADES: 3\n" +
     "- ADDS: ENABLED"

EXECUTION_CONDITIONAL = "- MAX_RISK: 0.25R\n" +
     "- MAX_TRADES: 1\n" +
     "- ADDS: DISABLED"

// --- Derived Risk Code ---
string riskCode = "K-NORMAL"
if riskGovernorState == "LOCKED"
    riskCode := "K-LOCKED"
else if riskGovernorState == "REDUCED"
    riskCode := "K-REDUCED"

// --- Emoji Resolver (strict, fixed ‚Äî 4 emojis only) ---
f_alertEmoji(string alertType) =>
    string emoji = "‚ö™"
    if alertType == ALERT_ARMED
        emoji := "üü¢"
    else if alertType == ALERT_CANDIDATE
        emoji := "üü°"
    else if alertType == ALERT_BLOCKED
        emoji := "üî¥"
    else
        emoji := "‚ö™"
    emoji

// --- Severity Prefix (for email/Discord inbox filtering) ---
f_alertPrefix(string alertType) =>
    string prefix = "[I]"
    if alertType == ALERT_ARMED
        prefix := "[A]"
    else if alertType == ALERT_CANDIDATE
        prefix := "[C]"
    else if alertType == ALERT_BLOCKED
        prefix := "[B]"
    else
        prefix := "[I]"
    prefix

// --- Header Builder (Scan Line ‚Äî what you read in Discord/email previews) ---
f_alertHeader(string alertType, string symbol, string pReason, string rState, string sStr) =>
    string emoji = f_alertEmoji(alertType)
    string prefix = f_alertPrefix(alertType)
    emoji + " " +
     prefix + " " +
     alertType + " | " +
     symbol + " | " +
     pReason + " | " +
     rState + " | " +
     sStr

// --- Body Builder (Audit Detail ‚Äî opened when needed) ---
f_alertBody(string pReason, string contribReasons, string permission, string execution) =>
    "Primary: " + pReason + "\n" +
     "Contributing: [" + contribReasons + "]\n\n" +
     "PERMISSION: " + permission + "\n" +
     "EXECUTION:\n" + execution

// --- JSON Payload Builder (Machine-Parsable ‚Äî for webhook receiver) ---
f_buildJson(string aType, string symbol, string assetClass, string pReason, string contribReasons, string permission, string execMaxRisk, int execMaxTrades, string execAdds, string direction, int score, int criteria, string entry, string volState, int mtf, int rsi, string session, string playbook, string regime, string rState) =>
    string p = '{"type":"' + aType + '","pair":"' + symbol + '","asset_class":"' + assetClass + '"'
    p := p + ',"primary":"' + pReason + '","contributing":"' + contribReasons + '"'
    p := p + ',"permission":"' + permission + '"'
    p := p + ',"execution":{"max_risk":"' + execMaxRisk + '","max_trades":' + str.tostring(execMaxTrades) + ',"adds":"' + execAdds + '"}'
    p := p + ',"context":{"direction":"' + direction + '","score":' + str.tostring(score)
    p := p + ',"criteria":' + str.tostring(criteria) + ',"entry":"' + entry + '"'
    p := p + ',"vol_state":"' + volState + '","mtf":' + str.tostring(mtf) + ',"rsi":' + str.tostring(rsi)
    p := p + ',"session":"' + session + '","playbook":"' + playbook + '"'
    p := p + ',"regime":"' + regime + '","risk_state":"' + rState + '"}}'
    p

// --- Full Alert Builder (Scan Line + JSON Body) ---
f_buildAlert(string alertType, string symbol, string pReason, string contribReasons, string permission, string execution, string rState, int scoreValue) =>
    string sStr = "U-SCORE-" + str.tostring(scoreValue)
    string header = f_alertHeader(alertType, symbol, pReason, rState, sStr)
    string body = f_alertBody(pReason, contribReasons, permission, execution)
    header + "\n" + "\u2014\n" + body

// Current timeframe EMAs
fastEMA = ta.ema(close, fastLength)
midEMA = ta.ema(close, midLength)
slowEMA = ta.ema(close, slowLength)
trendEMA = ta.ema(close, trendLength)

// EMA slopes
trendSlope = trendEMA - trendEMA[5]
trendSlopeUp = trendSlope > 0
trendSlopeDown = trendSlope < 0

// ADX calculation
dirmov(len) =>
    up = ta.change(high)
    down = -ta.change(low)
    plusDM = na(up) ? na : (up > down and up > 0 ? up : 0)
    minusDM = na(down) ? na : (down > up and down > 0 ? down : 0)
    truerange = ta.rma(ta.tr, len)
    plus = fixnan(100 * ta.rma(plusDM, len) / truerange)
    minus = fixnan(100 * ta.rma(minusDM, len) / truerange)
    [plus, minus]

[diPlus, diMinus] = dirmov(adxLength)
adxValue = 100 * ta.rma(math.abs(diPlus - diMinus) / (diPlus + diMinus == 0 ? 1 : diPlus + diMinus), adxLength)

// Multi-timeframe alignment
mtf1Bullish = request.security(syminfo.tickerid, mtf1, ta.ema(close, fastLength) > ta.ema(close, slowLength), gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off)
mtf2Bullish = request.security(syminfo.tickerid, mtf2, ta.ema(close, fastLength) > ta.ema(close, slowLength), gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off)
mtf3Bullish = request.security(syminfo.tickerid, mtf3, ta.ema(close, fastLength) > ta.ema(close, slowLength), gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off)

mtfBullCount = (mtf1Bullish ? 1 : 0) + (mtf2Bullish ? 1 : 0) + (mtf3Bullish ? 1 : 0)
mtfBearCount = (not mtf1Bullish ? 1 : 0) + (not mtf2Bullish ? 1 : 0) + (not mtf3Bullish ? 1 : 0)
mtfFullAlignment = mtfBullCount == 3 or mtfBearCount == 3
mtfAlignmentBullish = mtfBullCount == 3

// Trend Score Calculation (0-100)
trendScore = 0.0

// EMA alignment (40 points)
if fastEMA > midEMA and midEMA > slowEMA
    trendScore += 20  // Bullish alignment
if midEMA > slowEMA
    trendScore += 10
if fastEMA > midEMA
    trendScore += 10

if fastEMA < midEMA and midEMA < slowEMA
    trendScore += 20  // Bearish alignment
if midEMA < slowEMA
    trendScore += 10
if fastEMA < midEMA
    trendScore += 10

// HTF trend direction (20 points)
if (close > trendEMA and trendSlopeUp) or (close < trendEMA and trendSlopeDown)
    trendScore += 20

// ADX momentum (20 points)
if adxValue > adxThreshold
    trendScore += 20

// MTF alignment (20 points)
if mtfFullAlignment
    trendScore += 20

// ============================================================================
// CALCULATIONS: ATR VOLATILITY SYSTEM
// ============================================================================

// Multi-timeframe ATR values
atrCurrent = ta.atr(atrLength)
atrH1 = request.security(syminfo.tickerid, "60", ta.atr(atrLength), gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off)
atrH4 = request.security(syminfo.tickerid, "240", ta.atr(atrLength), gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off)
atrD1 = request.security(syminfo.tickerid, "D", ta.atr(atrLength), gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off)

// ATR Filter (Now Adjustable! 0% = disabled, 100% = balanced, 120% = strict)
atrMA = ta.sma(atrCurrent, 50)
atrFilterThreshold = atrFilterPercent / 100.0
atrFilterActive = atrFilterPercent == 0 ? true : atrCurrent > (atrMA * atrFilterThreshold)
atrFilterCurrentPercent = atrMA > 0 ? (atrCurrent / atrMA) * 100 : 100  // For display

// ATR Percentile
atrPercentile = ta.percentrank(atrD1, atrPercentileLookback)

// ATR Percentile Floor check (new filter)
atrPercentileOK = atrPercentile >= atrPercentileFloor

// ATR State Detection (QUIET/EXPLODE/TREND/MIXED)
// Using relative hierarchy with baselines
baseCurr = ta.ema(atrCurrent, atrBaseline)
baseH1 = request.security(syminfo.tickerid, "60", ta.ema(ta.atr(atrLength), atrBaseline), gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off)
baseH4 = request.security(syminfo.tickerid, "240", ta.ema(ta.atr(atrLength), atrBaseline), gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off)
baseD1 = request.security(syminfo.tickerid, "D", ta.ema(ta.atr(atrLength), atrBaseline), gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off)

// Relative metrics
rCur = baseCurr != 0 ? atrCurrent / baseCurr : atrCurrent
rH1 = baseH1 != 0 ? atrH1 / baseH1 : atrH1
rH4 = baseH4 != 0 ? atrH4 / baseH4 : atrH4
rD1 = baseD1 != 0 ? atrD1 / baseD1 : atrD1

// Hierarchy detection
sep = 1.0 + sepTolerance
q1s = rH1 > rCur * sep ? 1 : 0  // QUIET signals
q2s = rH4 > rH1 * sep ? 1 : 0
q3s = rD1 > rH4 * sep ? 1 : 0
e1s = rCur > rH1 * sep ? 1 : 0  // EXPLODE signals
e2s = rH1 > rH4 * sep ? 1 : 0
e3s = rH4 > rD1 * sep ? 1 : 0

quietStrong = q1s + q2s + q3s
explodeStrong = e1s + e2s + e3s

// TREND detection (equality check)
m1 = math.max(math.abs(rCur), math.abs(rH4))
m2 = math.max(math.abs(rH4), math.abs(rD1))
approx1 = m1 == 0 ? true : math.abs(rCur - rH4) / m1 <= eqTolerance
approx2 = m2 == 0 ? true : math.abs(rH4 - rD1) / m2 <= eqTolerance
isTrend = approx1 and approx2 and not (quietStrong >= 2 or explodeStrong >= 2)

// State determination
var string atrState = "MIXED"
if quietStrong == 3
    atrState := "QUIET"
else if explodeStrong == 3
    atrState := "EXPLODE"
else if isTrend
    atrState := "TREND"
else
    atrState := "MIXED"

// ============================================================================
// CALCULATIONS: RSI MOMENTUM SYSTEM
// ============================================================================

// Multi-timeframe RSI
rsiCurrent = ta.rsi(close, rsiLength)
rsiH1 = request.security(syminfo.tickerid, "60", ta.rsi(close, rsiLength), gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off)
rsiH4 = request.security(syminfo.tickerid, "240", ta.rsi(close, rsiLength), gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off)
rsiD1 = request.security(syminfo.tickerid, "D", ta.rsi(close, rsiLength), gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off)

// RSI MTF alignment
rsiBullCount = (rsiCurrent > 50 ? 1 : 0) + (rsiH1 > 50 ? 1 : 0) + (rsiH4 > 50 ? 1 : 0) + (rsiD1 > 50 ? 1 : 0)
rsiBearCount = (rsiCurrent < 50 ? 1 : 0) + (rsiH1 < 50 ? 1 : 0) + (rsiH4 < 50 ? 1 : 0) + (rsiD1 < 50 ? 1 : 0)
rsiAllBull = rsiBullCount == 4
rsiAllBear = rsiBearCount == 4

// ============================================================================
// üì∞ CALCULATIONS: NEWS RISK DETECTION (NEW DAY 4)
// ============================================================================

// Time-based high-impact event filtering
// Block trading during highest-risk periods (session opens, major overlaps)
var bool newsRiskHigh = false
var string newsRiskReason = ""

// Get current UTC hour for risk detection
utcHourNow = hour(timenow, "UTC")

// HIGH RISK PERIODS (30-min windows):
// 1. London Open (08:00-08:30 UTC) = 7:00-7:30pm AEDT
londonOpenRisk = utcHourNow == 8

// 2. NY Open (13:00-13:30 UTC) = 12:00-12:30am AEDT  
nyOpenRisk = utcHourNow == 13

// 3. Major news times (08:30 UTC = NFP, CPI, etc)
majorNewsTimeRisk = (utcHourNow == 8)  // Covered by London open

// Combine risk factors
newsRiskHigh := londonOpenRisk or nyOpenRisk

if newsRiskHigh
    if londonOpenRisk
        newsRiskReason := "London Open"
    else if nyOpenRisk
        newsRiskReason := "NY Open"
else
    newsRiskReason := "Clear"

// ============================================================================
// üìç CALCULATIONS: S/R PROXIMITY (NEW DAY 4)
// ============================================================================

// Simple but effective S/R detection using recent swing highs/lows
// Professional approach: Distance measured in ATR units for scale-independence

// Lookback for swing detection (100 bars = recent structure)
srLookback = 100

// Detect swing highs and lows
swingHigh = ta.highest(high, srLookback)
swingLow = ta.lowest(low, srLookback)

// Calculate distances in ATR units (scale-independent measurement)
atrValue = ta.atr(14)
distToResistance = atrValue > 0 ? (swingHigh - close) / atrValue : 10.0
distToSupport = atrValue > 0 ? (close - swingLow) / atrValue : 10.0

// Find nearest S/R
distToNearestSR = math.min(distToResistance, distToSupport)

// Proximity warnings (institutional thresholds)
tooCloseToSR = distToNearestSR < 0.5  // Within 0.5 ATR = danger zone
moderateProximity = distToNearestSR >= 0.5 and distToNearestSR < 1.5

// S/R Status determination
var string srStatus = ""
var color srStatusColor = color.green

if tooCloseToSR
    srStatus := "TOO CLOSE ‚ö†"
    srStatusColor := color.red
else if moderateProximity
    srStatus := "MODERATE"
    srStatusColor := color.orange
else
    srStatus := "CLEAR ‚úì"
    srStatusColor := color.green

// S/R Scoring for overall score (0-5 points)
var float srProximityScore = 0.0
if distToNearestSR >= 2.0
    srProximityScore := 5.0  // Excellent - clear air
else if distToNearestSR >= 1.5
    srProximityScore := 4.0  // Good
else if distToNearestSR >= 1.0
    srProximityScore := 3.0  // Acceptable
else if distToNearestSR >= 0.5
    srProximityScore := 2.0  // Marginal
else
    srProximityScore := 0.0  // Too close - avoid

// ============================================================================
// CALCULATIONS: ENTRY ZONE ANALYSIS (NEW DAY 4)
// ============================================================================

// EMA Pullback Entry Quality System
// Measures how well-positioned price is for trend continuation entry

// Calculate distance from trend EMAs (already have fast/mid/slow from earlier)
distFromFastEMA = atrValue > 0 ? math.abs(close - fastEMA) / atrValue : 10.0
distFromMidEMA = atrValue > 0 ? math.abs(close - midEMA) / atrValue : 10.0
distFromSlowEMA = atrValue > 0 ? math.abs(close - slowEMA) / atrValue : 10.0

// Entry Zone Quality Assessment (0-5 base points)
var string entryZoneQuality = ""
var float entryZoneScore = 0.0
var color entryZoneColor = color.gray

if distFromFastEMA < 0.3
    entryZoneQuality := "HOT ZONE"
    entryZoneScore := 5.0
    entryZoneColor := color.lime
else if distFromFastEMA < 0.5
    entryZoneQuality := "OPTIMAL ‚úì"
    entryZoneScore := 4.0
    entryZoneColor := color.green
else if distFromFastEMA < 1.0
    entryZoneQuality := "ACCEPTABLE"
    entryZoneScore := 3.0
    entryZoneColor := color.yellow
else if distFromMidEMA < 0.5
    entryZoneQuality := "DEEP PULLBACK"
    entryZoneScore := 2.0
    entryZoneColor := color.orange
else
    entryZoneQuality := "EXTENDED ‚úó"
    entryZoneScore := 0.0
    entryZoneColor := color.red

// RSI Momentum Bonus (0-2 bonus points)
// Detects when RSI confirms the trend direction
var float rsiMomentumBonus = 0.0
var string rsiMomentumStatus = ""

// RSI 50-line crosses (momentum shifts)
rsiCrossedUp = ta.crossover(rsiCurrent, 50)
rsiCrossedDown = ta.crossunder(rsiCurrent, 50)

// Check if RSI cross aligns with trend direction
rsiBullishMomentum = (mtfAlignmentBullish and rsiCrossedUp) or (mtfAlignmentBullish and rsiCurrent > 55)
rsiBearishMomentum = (mtfBearCount == 3 and rsiCrossedDown) or (mtfBearCount == 3 and rsiCurrent < 45)

if rsiBullishMomentum or rsiBearishMomentum
    if rsiCrossedUp or rsiCrossedDown
        rsiMomentumBonus := 2.0  // Fresh cross = strong momentum
        rsiMomentumStatus := "CROSSED 50 ‚úì‚úì"
    else
        rsiMomentumBonus := 1.0  // Strong RSI position
        rsiMomentumStatus := "STRONG ‚úì"
else if (mtfAlignmentBullish and rsiCurrent > 50) or (mtfBearCount == 3 and rsiCurrent < 50)
    rsiMomentumBonus := 0.5  // Aligned but weak
    rsiMomentumStatus := "ALIGNED"
else
    rsiMomentumBonus := 0.0
    rsiMomentumStatus := "NEUTRAL"

// TOTAL ENTRY SCORE (0-7 points: 5 base + 2 bonus)
entryTotalScore = entryZoneScore + rsiMomentumBonus

// Entry Rating
var string entryRating = ""
if entryTotalScore >= 6.5
    entryRating := "EXCELLENT"
else if entryTotalScore >= 5.0
    entryRating := "GOOD"
else if entryTotalScore >= 3.5
    entryRating := "FAIR"
else if entryTotalScore >= 2.0
    entryRating := "POOR"
else
    entryRating := "AVOID"

// ============================================================================
// CALCULATIONS: EXECUTION CONTEXT (ENHANCED DAY 4)
// ============================================================================

// SESSION DETECTION (based on UTC - global trading sessions)
// Get UTC time for session determination
utcHour = hour(timenow, "UTC")
utcMinute = minute(timenow, "UTC")

// Determine session based on UTC hour (global standard)
var string currentSession = "Unknown"
var string sessionVolHint = ""

// Trading sessions in UTC:
// Tokyo: 00:00-08:00 | London: 08:00-13:00 | LON+NY: 13:00-17:00 | NY: 17:00-22:00
if utcHour >= 0 and utcHour < 8
    currentSession := "Tokyo"
    sessionVolHint := "Low-Med"
else if utcHour >= 8 and utcHour < 13
    currentSession := "London"
    sessionVolHint := "High"
else if utcHour >= 13 and utcHour < 17
    currentSession := "LON+NY"
    sessionVolHint := "Extreme"
else if utcHour >= 17 and utcHour < 22
    currentSession := "NY"
    sessionVolHint := "High"
else
    currentSession := "Off-Hours"
    sessionVolHint := "Low"

// ============================================================================
// SESSION LOCK SYSTEM (v1.8)
// ============================================================================

// Directional Efficiency (Body / Range) - measured in playbook direction
candleRange = high - low
candleBody = math.abs(close - open)
rawEfficiency = candleRange > 0 ? candleBody / candleRange : 0

// Direction of current candle
candleBullish = close > open
candleBearish = close < open

// Armed state tracking (persists across bars)
var bool isArmed = false
var int armedDirection = 0  // 1 = long, -1 = short
var float armedScore = 0.0
var string armedSession = ""
var int barsAboveThreshold = 0
var string disarmReason = ""
var string currentPlaybook = "NO TRADE"

// Alert state tracking (for state-change detection)
var bool wasArmed = false
var int wasArmedDirection = 0
var string lastSession = ""

// CANDIDATE state tracking (dual memory for intra-bar + confirmed)
var bool wasCandidate_rt = false      // realtime memory - prevents intra-bar spam
var bool wasCandidate_close = false   // bar close memory - for diagnostics
var int wasCandidateDir_rt = 0        // track direction changes too

// Session change detection (unified - used by alerts AND session lock)
// lastSession only updates on bar close, so this is TRUE throughout first bar of new session
sessionJustChanged = currentSession != lastSession
// v2.1: One-shot event for SESSION RESET alert (fires only on first tick of new session bar)
sessionResetEvent = sessionJustChanged and barstate.isnew

// Structural damage detection (calculated after score is computed - placeholder here)
var bool structuralDamage = false
var bool efficiencyCollapse = false
var bool mtfBroken = false
var bool emaCompressed = false

// TIME TO BAR CLOSE
tfSeconds = timeframe.in_seconds()
tfMilliseconds = tfSeconds * 1000
barStartTime = time
currentTime = timenow
barTimeElapsed = (currentTime - barStartTime) / 1000  // seconds elapsed
barTimeRemaining = math.max(0, tfSeconds - barTimeElapsed)
minutesRemaining = math.floor(barTimeRemaining / 60)
secondsRemaining = math.floor(barTimeRemaining % 60)

var string barCloseText = ""
var bool barCloseWarning = false
var color barTimerColor = color.white
var string barTimerIcon = ""

if barstate.isrealtime
    // Determine warning level and visual styling
    if minutesRemaining <= barTimerCritical
        barCloseWarning := true
        barTimerColor := color.rgb(255, 50, 50)  // Bright red
        barTimerIcon := " üî¥"
        barCloseText := "‚è∞ " + str.tostring(minutesRemaining) + "m " + str.tostring(secondsRemaining) + "s" + barTimerIcon
    else if minutesRemaining <= barTimerWarning
        barCloseWarning := true
        barTimerColor := color.rgb(255, 200, 0)  // Yellow
        barTimerIcon := " üü°"
        barCloseText := str.tostring(minutesRemaining) + "m " + str.tostring(secondsRemaining) + "s" + barTimerIcon
    else if minutesRemaining <= barTimerCaution
        barCloseWarning := false
        barTimerColor := color.rgb(255, 165, 0)  // Orange
        barTimerIcon := " üü†"
        barCloseText := str.tostring(minutesRemaining) + "m"
    else
        barCloseWarning := false
        barTimerColor := color.rgb(100, 200, 100)  // Green
        barTimerIcon := ""
        barCloseText := str.tostring(minutesRemaining) + "m"
else
    barCloseText := "---"
    barCloseWarning := false
    barTimerColor := color.gray
    barTimerIcon := ""

// SPREAD MONITORING (Improved - using current bar high-low range)
// Note: True spread requires broker data, this is an approximation
// Using recent volatility as proxy for expected range
recentVolatility = ta.atr(14)
currentBarRange = high - low
expectedRange = recentVolatility * 0.5  // Expected range for current bar time
rangeRatio = expectedRange > 0 ? currentBarRange / expectedRange : 1.0

var string spreadStatus = "NORMAL"
var bool spreadWarning = false
if rangeRatio > spreadWarningMultiplier
    spreadStatus := "WIDE"
    spreadWarning := true
else if rangeRatio > (spreadWarningMultiplier * 0.7)
    spreadStatus := "ELEVATED"
    spreadWarning := false
else
    spreadStatus := "NORMAL"
    spreadWarning := false

// For historical bars, use different logic
if not barstate.isrealtime
    spreadStatus := "---"
    spreadWarning := false

// ============================================================================
// CALCULATIONS: NEWS FILTER (SIMPLIFIED FOR DAY 1)
// ============================================================================

// For Day 1, we'll use a placeholder
// Will integrate full economic calendar on Day 4
newsStatusClear = true  // Assume clear for now
newsNextEventTime = "None 24h"  // Placeholder

// ============================================================================
// 4-CRITERIA EVALUATION
// ============================================================================

// CRITERION 1: Trend Score ‚â• Threshold
criterion1Pass = trendScore >= minTrendScore
criterion1Value = str.tostring(math.round(trendScore)) + "/100"
criterion1Status = criterion1Pass ? "‚úÖ" : "‚ùå"

// CRITERION 2: MTF Alignment (3/3 required)
criterion2Pass = mtfFullAlignment
criterion2Value = mtfAlignmentBullish ? "BULL 3/3" : mtfBearCount == 3 ? "BEAR 3/3" : str.tostring(mtfBullCount) + "/3"
criterion2Status = criterion2Pass ? "‚úÖ" : "‚ùå"

// CRITERION 3: Volatility Ready
var bool criterion3Pass = false
var string criterion3Detail = ""

if atrState == "TREND" and acceptTrend
    criterion3Pass := true
    criterion3Detail := "TREND ‚úì"
else if atrState == "EXPLODE" and acceptExplode
    if atrPercentile >= explodeMinPercentile and atrPercentile <= explodeMaxPercentile
        criterion3Pass := true
        criterion3Detail := "EXPLODE (" + str.tostring(math.round(atrPercentile)) + "%ile)"
    else
        criterion3Pass := false
        criterion3Detail := "EXPLODE (Extreme " + str.tostring(math.round(atrPercentile)) + "%ile)"
else if atrState == "QUIET" and acceptQuiet
    if atrPercentile >= quietMinPercentile and atrPercentile <= quietMaxPercentile
        criterion3Pass := true
        criterion3Detail := "QUIET (" + str.tostring(math.round(atrPercentile)) + "%ile)"
    else
        criterion3Pass := false
        criterion3Detail := "QUIET (Edge " + str.tostring(math.round(atrPercentile)) + "%ile)"
else if atrState == "MIXED"
    criterion3Pass := false
    criterion3Detail := "MIXED"
else
    criterion3Pass := false
    criterion3Detail := atrState

criterion3Value = criterion3Detail
criterion3Status = criterion3Pass ? "‚úÖ" : "‚ùå"

// CRITERION 4: News Risk Status (was Criterion 5 in v1.6)
// ATR filter REMOVED as hard gate - now display-only
criterion4Pass = not newsRiskHigh  // Pass if NOT in high-risk period
criterion4Value = newsRiskHigh ? "HIGH RISK" : "CLEAR"
criterion4Status = criterion4Pass ? "‚úÖ" : "‚ùå"

// ATR PERCENTILE - DISPLAY ONLY (Institutional Guidance)
// Under 30%: IDEAL entry, expansion likely
// 30-60%: NORMAL, proceed with full size
// 60-80%: ELEVATED, reduce size 50%
// Over 80%: EXHAUSTED, pass or exit only
atrPercentileValue = math.round(atrPercentile)
atrGuidance = atrPercentileValue < 30 ? "IDEAL" : atrPercentileValue < 60 ? "NORMAL" : atrPercentileValue < 80 ? "ELEVATED" : "EXHAUSTED"
atrGuidanceColor = atrPercentileValue < 30 ? color.lime : atrPercentileValue < 60 ? color.green : atrPercentileValue < 80 ? color.yellow : color.red

// Count criteria met (NOW 4 CRITERIA)
criteriaMet = (criterion1Pass ? 1 : 0) + (criterion2Pass ? 1 : 0) + (criterion3Pass ? 1 : 0) + (criterion4Pass ? 1 : 0)

// ============================================================================
// SCORING SYSTEM (0-100 points, properly scaled)
// ============================================================================

var float overallScore = 0.0
overallScore := 0.0  // Reset to 0 (no base score bonus)

// 1. TREND QUALITY SCORE (0-40 points) - Primary driver
trendQualityScore = (trendScore / 100) * 40
overallScore += trendQualityScore

// 2. VOLATILITY REGIME SCORE (0-30 points) - Key factor
var float volatilityScore = 0.0
if atrState == "TREND"
    volatilityScore := 25.0
else if atrState == "EXPLODE"
    if atrPercentile >= 20 and atrPercentile <= 80
        volatilityScore := 20.0
    else if atrPercentile >= 15 and atrPercentile <= 90
        volatilityScore := 15.0
    else
        volatilityScore := 0.0
else if atrState == "QUIET"
    if atrPercentile >= 30 and atrPercentile <= 70
        volatilityScore := 15.0
    else if atrPercentile >= 15 and atrPercentile <= 85
        volatilityScore := 10.0
    else
        volatilityScore := 0.0
else  // MIXED
    volatilityScore := 0.0

// ATR Filter bonus
if atrFilterActive
    volatilityScore += 5.0

overallScore += volatilityScore

// 3. MOMENTUM ALIGNMENT SCORE (0-20 points) - Confirmation
var float momentumScore = 0.0
if rsiAllBull or rsiAllBear
    momentumScore := 20.0
else if rsiBullCount >= 3 or rsiBearCount >= 3
    momentumScore := 15.0
else if rsiBullCount >= 2 or rsiBearCount >= 2
    momentumScore := 8.0
else
    momentumScore := 0.0

overallScore += momentumScore

// 4. RISK CONTEXT SCORE (0-5 points) - Enhanced Day 4
// Combines: Daily range position + Session quality + News risk
dailyHigh = request.security(syminfo.tickerid, "D", high, gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off)
dailyLow = request.security(syminfo.tickerid, "D", low, gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off)
dailyRange = dailyHigh - dailyLow
dailyPosition = dailyRange > 0 ? ((close - dailyLow) / dailyRange * 100) : 50

var float riskScore = 0.0

// Daily range position (0-1.5 points)
if dailyPosition >= 40 and dailyPosition <= 60
    riskScore := 1.5  // Mid-range = safest
else if dailyPosition >= 30 and dailyPosition <= 70
    riskScore := 1.0  // Acceptable
else
    riskScore := 0.5  // Extremes

// Session quality bonus (0-2 points)
if currentSession == "Tokyo" or currentSession == "London"
    riskScore += 1.5  // Your available sessions
else if currentSession == "LON+NY"
    riskScore += 2.0  // Best session (but you're asleep)
else if currentSession == "NY"
    riskScore += 1.0  // Good session  
else
    riskScore += 0.5  // Off-hours

// News risk penalty (-1.5 points)
if newsRiskHigh
    riskScore -= 1.5  // Penalty for high-risk times

// Clamp to 0-5 range
riskScore := math.max(0, math.min(5, riskScore))

overallScore += riskScore

// 5. PRICE ACTION SCORE (0-5 points) - Enhanced Day 4
// Combines: S/R proximity (60%) + Entry zone quality (40%)
priceActionScore = 0.0

// S/R proximity component (0-3 points = 60%)
priceActionScore += (srProximityScore / 5.0) * 3.0

// Entry zone component (0-2 points = 40%)
priceActionScore += (math.min(5.0, entryZoneScore) / 5.0) * 2.0

overallScore += priceActionScore

// Cap at 100
overallScore := math.min(100, overallScore)

// ============================================================================
// üìä RISK MANAGEMENT CALCULATIONS (NEW DAY 3)
// ============================================================================

// ============================================================================
// INVALIDATION-BASED RISK MANAGEMENT (Institutional Approach)
// ============================================================================
// Invalidation = The price level where the trade idea is WRONG
// Stop placement is derived from invalidation, not arbitrary ATR multiples

// Buffer for invalidation (0.5 ATR beyond EMA to avoid wick stops)
invalidationBuffer = atrCurrent * 0.5

// Calculate invalidation and stop levels based on setup type
var float invalidationLevel = na
var float stopLevel = na
var float targetLevel = na
var float riskReward = 2.0
var string invalidationReason = ""

if mtfAlignmentBullish
    // Bullish: Invalid if price closes back below fast EMA
    invalidationLevel := fastEMA - invalidationBuffer
    stopLevel := invalidationLevel - (atrCurrent * 0.1)
    targetLevel := close + (math.abs(close - stopLevel) * 2.0)
    invalidationReason := "Below EMA"
else if mtfBearCount == 3
    // Bearish: Invalid if price closes back above fast EMA
    invalidationLevel := fastEMA + invalidationBuffer
    stopLevel := invalidationLevel + (atrCurrent * 0.1)
    targetLevel := close - (math.abs(stopLevel - close) * 2.0)
    invalidationReason := "Above EMA"
else
    invalidationLevel := close - atrCurrent
    stopLevel := close - (atrCurrent * 1.1)
    targetLevel := close + atrCurrent
    invalidationReason := "No Direction"

// Calculate distances and R:R
riskDistance = math.abs(close - stopLevel)
rewardDistance = math.abs(targetLevel - close)
riskReward := riskDistance > 0 ? rewardDistance / riskDistance : 0.0

// Convert to pips (for display)
pipMultiplier = syminfo.mintick * 10
invalidationPips = math.round(math.abs(close - invalidationLevel) / pipMultiplier)
riskPips = math.round(riskDistance / pipMultiplier)
rewardPips = math.round(rewardDistance / pipMultiplier)
stopPips = riskPips
targetPips = rewardPips
stopDistance = riskDistance
targetDistance = rewardDistance

// ============================================================================
// üìù VOLATILITY EXPLANATION (NEW DAY 3)
// ============================================================================

var string volExplanation = ""
if atrState == "TREND"
    volExplanation := "Steady consistent movement across timeframes. Ideal trending conditions."
else if atrState == "EXPLODE"
    volExplanation := "Sharp spike in activity. Breakout or news-driven. High risk/reward."
else if atrState == "QUIET"
    volExplanation := "Compressed range, consolidation. Potential breakout setup forming."
else
    volExplanation := "Conflicting volatility signals. Mixed market structure, avoid."

// Trend explanation
var string trendExplanation = ""
if fastEMA > midEMA and midEMA > slowEMA
    trendExplanation := "Fast > Mid > Slow ‚úì Clean bullish alignment"
else if fastEMA < midEMA and midEMA < slowEMA
    trendExplanation := "Fast < Mid < Slow ‚úì Clean bearish alignment"
else
    trendExplanation := "Mixed EMA structure ‚úó No clear trend"

// ADX interpretation
var string adxInterpretation = ""
if adxValue > 25
    adxInterpretation := "Strong"
else if adxValue > 20
    adxInterpretation := "Moderate"
else
    adxInterpretation := "Weak"

// ============================================================================
// STATUS DETERMINATION (Legacy ‚Äî feeds Standard/Full display modes)
// ============================================================================

var string tradeStatus = "NO TRADE"
var color tradeStatusColor = colorNoTradeRed
var string tradeStatusType = ""
var string positionSizeRec = ""

// OPTION B: CONDITIONAL STRICTNESS
// 5/5 = ALWAYS TRADE
// 4/5 = TRADE if Trend+MTF pass AND score ‚â•85
//     = CAUTION if Trend+MTF pass AND score 75-84
//     = NO TRADE if Trend+MTF pass AND score <75
//     = NO TRADE if Trend OR MTF fails (critical)
// 3/5 = CAUTION if score ‚â•75, else NO TRADE
// ‚â§2/5 = ALWAYS NO TRADE

if criteriaMet == 5
    // Perfect - all criteria met
    tradeStatus := "TRADE"
    tradeStatusColor := colorTradeGreen
    positionSizeRec := "Full"
    // Check Entry Zone for label quality
    entryIsGood = str.contains(entryZoneQuality, "HOT") or str.contains(entryZoneQuality, "OPTIMAL")
    if overallScore >= 90 and entryIsGood
        tradeStatusType := "Textbook"
    else if overallScore >= 85
        tradeStatusType := "Strong"
    else
        tradeStatusType := "Good"

else if criteriaMet == 4
    // Check critical criteria (Trend Score & MTF Alignment)
    bool criticalPass = criterion1Pass and criterion2Pass
    
    if criticalPass
        // Critical criteria met, check score
        if overallScore >= 85
            tradeStatus := "TRADE"
            tradeStatusColor := colorTradeGreen
            positionSizeRec := "Full"
            tradeStatusType := "Strong"
        else if overallScore >= 75
            tradeStatus := "CAUTION"
            tradeStatusColor := colorCautionOrange
            positionSizeRec := "50%"
            tradeStatusType := "Decent"
        else
            tradeStatus := "NO TRADE"
            tradeStatusColor := colorNoTradeRed
            positionSizeRec := "Avoid"
            tradeStatusType := "Score Too Low"
    else
        // Critical criteria failed
        tradeStatus := "NO TRADE"
        tradeStatusColor := colorNoTradeRed
        positionSizeRec := "Avoid"
        if not criterion1Pass
            tradeStatusType := "Weak Trend"
        else
            tradeStatusType := "MTF Divergence"

else if criteriaMet == 3
    // Borderline case
    if overallScore >= 75
        tradeStatus := "CAUTION"
        tradeStatusColor := colorCautionOrange
        positionSizeRec := "25-50%"
        tradeStatusType := "Marginal"
    else
        tradeStatus := "NO TRADE"
        tradeStatusColor := colorNoTradeRed
        positionSizeRec := "Avoid"
        tradeStatusType := "Too Weak"

else
    // 2 or fewer criteria met - always avoid
    tradeStatus := "NO TRADE"
    tradeStatusColor := colorNoTradeRed
    positionSizeRec := "Avoid"
    if criterion3Pass == false
        tradeStatusType := "Vol Issue"
    else if criterion4Pass == false
        tradeStatusType := "Low ATR"
    else if criterion1Pass == false
        tradeStatusType := "Weak Trend"
    else if criterion2Pass == false
        tradeStatusType := "MTF Mixed"
    else
        tradeStatusType := "Multiple Issues"

// ============================================================================
// COMBINED CRITERIA CHECK (for alerts)
// ============================================================================
// Boolean: True when all 5 criteria are met
allCriteriaMet = criterion1Pass and criterion2Pass and criterion3Pass and criterion4Pass

// Derived variables for alert messages
trendDirection = (fastEMA > midEMA and midEMA > slowEMA) ? 1 : (fastEMA < midEMA and midEMA < slowEMA) ? -1 : 0
mtfAlignCount = mtfAlignmentBullish ? 3 : mtfBearCount
volatilityState = atrState
newsRiskLevel = newsRiskHigh ? "HIGH RISK" : "CLEAR"
currentSpread = currentBarRange
avgSpread = expectedRange

// ============================================================================
// GOVERNANCE PRE-CHECK (Layers 1-3 ‚Äî runs BEFORE session lock)
// ============================================================================
// These layers determine permission BEFORE arming is evaluated.
// Regime and Risk can PREVENT arming. UTCC cannot override them.
// ============================================================================

// --- LAYER 1: REGIME CHECK (Highest Authority) ---
var string regimeCode = "R-EXPANSION"
var string regimePermission = "FULL"

if atrState == "MIXED"
    regimeCode := "R-CHAOS"
    regimePermission := "STAND_DOWN"
else if atrState == "QUIET" and atrPercentile < 15
    regimeCode := "R-COMPRESSION"
    regimePermission := "STAND_DOWN"
else if currentSession == "Off-Hours"
    regimeCode := "R-OFFSESSION"
    regimePermission := "STAND_DOWN"
else if atrState == "QUIET"
    regimeCode := "R-COMPRESSION"
    regimePermission := "CONDITIONAL"
else if atrState == "EXPLODE"
    regimeCode := "R-TRANSITION"
    regimePermission := "CONDITIONAL"
else if atrState == "TREND"
    regimeCode := "R-EXPANSION"
    regimePermission := "FULL"

// --- LAYER 2: RISK GOVERNOR CHECK (Overrides UTCC, never upgrades) ---
var string riskPermission = "FULL"
if riskGovernorState == "LOCKED"
    riskPermission := "STAND_DOWN"
else if riskGovernorState == "REDUCED"
    riskPermission := "CONDITIONAL"
else
    riskPermission := "FULL"

// --- LAYER 3: RESOLVE FINAL PERMISSION (Most Restrictive Wins) ---
var string finalPermission = "FULL"
if regimePermission == "STAND_DOWN" or riskPermission == "STAND_DOWN"
    finalPermission := "STAND_DOWN"
else if regimePermission == "CONDITIONAL" or riskPermission == "CONDITIONAL"
    finalPermission := "CONDITIONAL"
else
    finalPermission := "FULL"

// ============================================================================
// SESSION LOCK: ARM/DISARM LOGIC (v1.8 + Governance Hardening)
// ============================================================================

// Directional efficiency - only measure candles moving WITH potential trade direction
bullishEfficiency = candleBullish ? rawEfficiency : 0.0
bearishEfficiency = candleBearish ? rawEfficiency : 0.0

// Structural damage checks
emaCompressed := trendDirection == 0
mtfBroken := mtfAlignCount < 3
efficiencyCollapse := (trendDirection == 1 and bullishEfficiency < efficiencyThreshold and candleBullish) or (trendDirection == -1 and bearishEfficiency < efficiencyThreshold and candleBearish)
structuralDamage := emaCompressed or mtfBroken or efficiencyCollapse

// Determine disarm reason for logging (institutional reason codes)
if emaCompressed
    disarmReason := "U-EMA-FLAT"
else if mtfBroken
    disarmReason := "U-MTF-MISALIGN"
else if efficiencyCollapse
    disarmReason := "U-EFFICIENCY-COLLAPSE"
else
    disarmReason := ""

// Count bars above threshold (for upgrade persistence)
// GOVERNANCE GATE: finalPermission != "STAND_DOWN" prevents arming during veto
meetsArmCriteria = allCriteriaMet and overallScore >= alertStrongThreshold and mtfAlignCount == 3 and trendDirection != 0 and finalPermission != "STAND_DOWN"
if meetsArmCriteria
    barsAboveThreshold := barsAboveThreshold + 1
else
    barsAboveThreshold := 0

// SESSION LOCK LOGIC
if enableSessionLock
    // Reset on session change - allows re-arming (uses unified sessionJustChanged)
    if sessionJustChanged
        isArmed := false
        armedDirection := 0
        armedScore := 0.0
        armedSession := ""
        barsAboveThreshold := 0
    
    // GOVERNANCE FORCED DISARM: If permission drops to STAND_DOWN while armed,
    // force disarm regardless of score or structural state. No exceptions.
    if isArmed and finalPermission == "STAND_DOWN"
        isArmed := false
        armedDirection := 0
        if regimePermission == "STAND_DOWN"
            disarmReason := regimeCode
        else
            disarmReason := riskCode
    
    // ARM: Requires persistence (bars above threshold)
    if not isArmed and barsAboveThreshold >= upgradePersistence
        isArmed := true
        armedDirection := trendDirection
        armedScore := overallScore
        armedSession := currentSession
    
    // DISARM: Requires BOTH score drop AND structural damage
    if isArmed
        scoreBelowDisarm = overallScore < (armedScore - disarmScoreThreshold)
        if scoreBelowDisarm and structuralDamage
            isArmed := false
            armedDirection := 0
else
    // Session lock disabled - use real-time state (still respects governance)
    isArmed := meetsArmCriteria
    armedDirection := trendDirection
    armedScore := overallScore

// PLAYBOOK DETERMINATION (based on armed state + volatility)

// ============================================================================
// INSTITUTIONAL PRIORITY RESOLVER ‚Äî Layers 4-6 (Post-Arming)
// ============================================================================
// Layers 1-3 (regime, risk, finalPermission) run BEFORE session lock.
// Layers 4-6 resolve primary reason, alert type, and execution using isArmed.
// ============================================================================

// --- LAYER 4: DETERMINE PRIMARY REASON (Highest Authority That Restricted) ---
var string primaryReason = "R-EXPANSION"
if regimePermission == "STAND_DOWN"
    primaryReason := regimeCode
else if riskPermission == "STAND_DOWN"
    primaryReason := riskCode
else if regimePermission == "CONDITIONAL"
    primaryReason := regimeCode
else if riskPermission == "CONDITIONAL"
    primaryReason := riskCode
else
    // Both regime and risk allow full ‚Äî regime is ALWAYS primary
    // INSTITUTIONAL RULE: UTCC codes (U-series) are NEVER primary. Ever.
    // Failed criteria surface in contributing reasons only.
    primaryReason := regimeCode

// --- LAYER 5: AUTO-SELECT ALERT TYPE ---
var string resolvedAlertType = ALERT_INFO
if finalPermission == "STAND_DOWN"
    resolvedAlertType := ALERT_BLOCKED
else if finalPermission == "FULL" and isArmed and allCriteriaMet
    resolvedAlertType := ALERT_ARMED
else if finalPermission == "CONDITIONAL" or (allCriteriaMet and not isArmed)
    resolvedAlertType := ALERT_CANDIDATE
else
    resolvedAlertType := ALERT_INFO

// --- LAYER 6: RESOLVE EXECUTION CONSTRAINT ---
var string resolvedExecution = EXECUTION_NONE
if finalPermission == "STAND_DOWN"
    resolvedExecution := EXECUTION_NONE
else if finalPermission == "CONDITIONAL"
    resolvedExecution := EXECUTION_CONDITIONAL
else
    resolvedExecution := EXECUTION_FULL

// --- BUILD CONTRIBUTING REASONS (Supporting Evidence) ---
var string contributingStr = ""
contributingStr := "U-MTF-" + str.tostring(mtfAlignCount) + "OF3"
contributingStr := contributingStr + ", U-SCORE-" + str.tostring(math.round(overallScore))
contributingStr := contributingStr + ", U-ATR-" + atrState
if not criterion1Pass
    contributingStr := contributingStr + ", U-TREND-WEAK"
if atrPercentile < 20
    contributingStr := contributingStr + ", U-ATR-BELOW-P" + str.tostring(math.round(atrPercentile))
if str.contains(entryZoneQuality, "EXTENDED")
    contributingStr := contributingStr + ", U-ENTRY-EXTENDED"
if tooCloseToSR
    contributingStr := contributingStr + ", U-SR-CLOSE"
if newsRiskHigh
    contributingStr := contributingStr + ", U-NEWS-RISK"

// ============================================================================
// END PRIORITY RESOLVER
// ============================================================================

if not isArmed
    currentPlaybook := "NO TRADE"
else
    if atrState == "TREND"
        currentPlaybook := armedDirection == 1 ? "CONTINUATION LONG" : "CONTINUATION SHORT"
    else if atrState == "EXPLODE"
        currentPlaybook := armedDirection == 1 ? "DEEP PULLBACK LONG" : "DEEP PULLBACK SHORT"
    else if atrState == "QUIET"
        currentPlaybook := "OBSERVATION ONLY"
    else
        currentPlaybook := "STAND DOWN"

// Armed status text for display
armedStatusText = isArmed ? (armedDirection == 1 ? "ARMED LONG" : "ARMED SHORT") : "DISARMED"
armedStatusColor = isArmed ? (armedDirection == 1 ? color.rgb(34, 171, 148) : color.rgb(239, 83, 80)) : color.gray

// ============================================================================
// INSTITUTIONAL DISPLAY COLOURS (4-Emoji Standard Mapping)
// ============================================================================
// These drive ALL display colouring. Derived from resolvedAlertType.
// No emoji in display text ‚Äî colour coding only.
// ============================================================================

var color instStatusBg = color.rgb(30, 30, 50)
var color instStatusText = color.rgb(100, 149, 237)

if resolvedAlertType == ALERT_ARMED
    instStatusBg := color.rgb(0, 60, 0)
    instStatusText := color.rgb(34, 197, 94)
else if resolvedAlertType == ALERT_CANDIDATE
    instStatusBg := color.rgb(60, 50, 0)
    instStatusText := color.rgb(234, 179, 8)
else if resolvedAlertType == ALERT_BLOCKED
    instStatusBg := color.rgb(60, 0, 0)
    instStatusText := color.rgb(239, 68, 68)
else
    instStatusBg := color.rgb(30, 30, 50)
    instStatusText := color.rgb(100, 149, 237)

// Display execution constraint strings (derived from finalPermission)
string displayExecRisk = "NONE"
int displayExecTrades = 0
if finalPermission == "FULL"
    displayExecRisk := "1.0R"
    displayExecTrades := 3
else if finalPermission == "CONDITIONAL"
    displayExecRisk := "0.25R"
    displayExecTrades := 1

// ============================================================================
// TABLE DISPLAY - INSTITUTIONAL v2.5.0
// ============================================================================

var table dashTable = na

// Determine position
tablePos = panelPosition == "Top Left" ? position.top_left : 
           panelPosition == "Top Right" ? position.top_right : 
           panelPosition == "Bottom Left" ? position.bottom_left : 
           position.bottom_right

// Determine font sizes
getSize(string s) =>
    s == "Tiny" ? size.tiny : s == "Small" ? size.small : s == "Normal" ? size.normal : s == "Large" ? size.large : size.huge

headerSize = getSize(headerFontSize)
statusSize = getSize(statusFontSize)
dataSize = getSize(dataFontSize)
scoreSize = getSize(scoreFontSize)

// Create table (dynamic rows based on display mode)
if barstate.isfirst
    maxRows = displayMode == "Minimal" ? 5 : 
              displayMode == "Compact" ? 17 : 
              displayMode == "Standard" ? 42 : 
              52  // Full mode
    
    dashTable := table.new(tablePos, 2, maxRows, 
         bgcolor=color.new(colorBody, panelTransparency),
         frame_color=color.new(colorHeader, borderTransparency),
         frame_width=frameWidth,
         border_width=borderWidth,
         border_color=color.new(colorHeader, borderTransparency))

// Draw table on last bar
if barstate.islast
    // Clear table (all rows)
    maxClearRows = displayMode == "Minimal" ? 4 : 
                   displayMode == "Compact" ? 16 : 
                   displayMode == "Standard" ? 41 : 
                   51  // Full mode
    table.clear(dashTable, 0, 0, 1, maxClearRows)
    
    row = 0
    
    // ========================================
    // TIER 1: INSTITUTIONAL STATUS (Always show)
    // ========================================
    
    // Row 0: Pair + Timeframe (header)
    table.cell(dashTable, 0, row, syminfo.ticker + " " + timeframe.period, 
         text_color=colorText, 
         text_size=headerSize, 
         bgcolor=color.new(colorHeader, panelTransparency),
         text_halign=text.align_left)
    table.cell(dashTable, 1, row, "", 
         bgcolor=color.new(colorHeader, panelTransparency))
    row += 1
    
    // Row 1: Alert Type | Primary Reason | Permission (institutional BG)
    table.cell(dashTable, 0, row, resolvedAlertType, 
         text_color=instStatusText, 
         text_size=statusSize, 
         bgcolor=color.new(instStatusBg, panelTransparency),
         text_halign=text.align_left)
    table.cell(dashTable, 1, row, primaryReason + " | " + finalPermission, 
         text_color=instStatusText, 
         text_size=scoreSize, 
         bgcolor=color.new(instStatusBg, panelTransparency),
         text_halign=text.align_right)
    row += 1
    
    // Row 2: Regime + Risk State
    table.cell(dashTable, 0, row, "REGIME", 
         text_color=colorText, 
         text_size=dataSize, 
         bgcolor=color.new(colorHeader, panelTransparency),
         text_halign=text.align_left)
    table.cell(dashTable, 1, row, regimeCode + " | " + riskCode, 
         text_color=colorText, 
         text_size=dataSize, 
         bgcolor=color.new(colorBody, panelTransparency),
         text_halign=text.align_right)
    row += 1
    
    // Row 3: Execution Constraint
    string execDisplayText = finalPermission == "STAND_DOWN" ? "NONE" : "MAX_RISK: " + displayExecRisk + " | TRADES: " + str.tostring(displayExecTrades)
    table.cell(dashTable, 0, row, "EXECUTION", 
         text_color=colorText, 
         text_size=dataSize, 
         bgcolor=color.new(colorHeader, panelTransparency),
         text_halign=text.align_left)
    table.cell(dashTable, 1, row, execDisplayText, 
         text_color=instStatusText, 
         text_size=dataSize, 
         bgcolor=color.new(colorBody, panelTransparency),
         text_halign=text.align_right)
    row += 1
    
    // ========================================
    // TIER 2: CRITERIA CHECKLIST (Compact mode)
    // ========================================
    
    if displayMode != "Minimal"
        // Header separator
        table.cell(dashTable, 0, row, "CRITERIA CHECKLIST", 
             text_color=colorText, 
             text_size=headerSize, 
             bgcolor=color.new(colorHeader, panelTransparency),
             text_halign=text.align_center)
        table.cell(dashTable, 1, row, "", 
             bgcolor=color.new(colorHeader, panelTransparency))
        row += 1
        
        // Criterion 1: Trend Score
        table.cell(dashTable, 0, row, criterion1Status + " 1. Trend Score", 
             text_color=criterion1Pass ? colorPass : colorFail, 
             text_size=dataSize, 
             bgcolor=color.new(colorBody, panelTransparency),
             text_halign=text.align_left)
        table.cell(dashTable, 1, row, criterion1Value, 
             text_color=colorText, 
             text_size=dataSize, 
             bgcolor=color.new(colorBody, panelTransparency),
             text_halign=text.align_right)
        row += 1
        
        // Criterion 2: MTF Alignment
        table.cell(dashTable, 0, row, criterion2Status + " 2. MTF Alignment", 
             text_color=criterion2Pass ? colorPass : colorFail, 
             text_size=dataSize, 
             bgcolor=color.new(colorBody, panelTransparency),
             text_halign=text.align_left)
        table.cell(dashTable, 1, row, criterion2Value, 
             text_color=colorText, 
             text_size=dataSize, 
             bgcolor=color.new(colorBody, panelTransparency),
             text_halign=text.align_right)
        row += 1
        
        // Criterion 3: Volatility Ready
        table.cell(dashTable, 0, row, criterion3Status + " 3. Volatility", 
             text_color=criterion3Pass ? colorPass : colorFail, 
             text_size=dataSize, 
             bgcolor=color.new(colorBody, panelTransparency),
             text_halign=text.align_left)
        table.cell(dashTable, 1, row, criterion3Value, 
             text_color=colorText, 
             text_size=dataSize, 
             bgcolor=color.new(colorBody, panelTransparency),
             text_halign=text.align_right)
        row += 1
        
        // Criterion 4: News Status (was criterion 5)
        table.cell(dashTable, 0, row, criterion4Status + " 4. News Status", 
             text_color=criterion4Pass ? colorPass : colorFail, 
             text_size=dataSize, 
             bgcolor=color.new(colorBody, panelTransparency),
             text_halign=text.align_left)
        table.cell(dashTable, 1, row, criterion4Value, 
             text_color=colorText, 
             text_size=dataSize, 
             bgcolor=color.new(colorBody, panelTransparency),
             text_halign=text.align_right)
        row += 1
        
        // ATR Percentile - DISPLAY ONLY (Institutional Guidance)
        table.cell(dashTable, 0, row, "ATR: " + str.tostring(atrPercentileValue) + "%", 
             text_color=atrGuidanceColor, 
             text_size=dataSize, 
             bgcolor=color.new(colorBody, panelTransparency),
             text_halign=text.align_left)
        table.cell(dashTable, 1, row, atrGuidance, 
             text_color=atrGuidanceColor, 
             text_size=dataSize, 
             bgcolor=color.new(colorBody, panelTransparency),
             text_halign=text.align_right)
        row += 1
        
        // PLAYBOOK (always shown ‚Äî institutional requirement)
        var color playbookColor = color.gray
        if currentPlaybook == "NO TRADE"
            playbookColor := color.gray
        else if str.contains(currentPlaybook, "OBSERVATION")
            playbookColor := color.rgb(255, 200, 0)
        else if str.contains(currentPlaybook, "STAND DOWN")
            playbookColor := color.rgb(255, 165, 0)
        else if armedDirection == 1
            playbookColor := color.rgb(34, 171, 148)
        else
            playbookColor := color.rgb(239, 83, 80)
        table.cell(dashTable, 0, row, "PLAYBOOK", 
             text_color=colorText, 
             text_size=dataSize, 
             bgcolor=color.new(colorHeader, panelTransparency),
             text_halign=text.align_left)
        table.cell(dashTable, 1, row, currentPlaybook, 
             text_color=playbookColor, 
             text_size=dataSize, 
             bgcolor=color.new(colorBody, panelTransparency),
             text_halign=text.align_right)
        row += 1
        
        // Verdict row (criteria count ‚Äî uses institutional status colour)
        verdictText = str.tostring(criteriaMet) + "/4 | Score: " + str.tostring(math.round(overallScore))
        
        table.cell(dashTable, 0, row, verdictText, 
             text_color=instStatusText, 
             text_size=dataSize, 
             bgcolor=color.new(colorHeader, panelTransparency),
             text_halign=text.align_center)
        table.cell(dashTable, 1, row, "", 
             bgcolor=color.new(colorHeader, panelTransparency))
        row += 1
        
        // ========================================
        // EXECUTION CONTEXT ROW (ENHANCED WITH TIMER WARNINGS)
        // ========================================
        
        // Show critical timer warning prominently if needed
        if showBarTimer and (minutesRemaining <= barTimerCritical)
            table.cell(dashTable, 0, row, barCloseText, 
                 text_color=barTimerColor, 
                 text_size=statusSize,  // Use larger status font for visibility
                 bgcolor=color.new(color.rgb(50, 0, 0), panelTransparency),  // Dark red background
                 text_halign=text.align_center)
            table.cell(dashTable, 1, row, "CLOSE SOON!", 
                 text_color=barTimerColor, 
                 text_size=statusSize, 
                 bgcolor=color.new(color.rgb(50, 0, 0), panelTransparency),
                 text_halign=text.align_center)
            row += 1
        
        // Build context string with essential trading info
        string sessionText = showSessionInfo ? currentSession : ""
        string timerText = showBarTimer and minutesRemaining > barTimerCritical ? barCloseText : ""
        string spreadText = showSpreadMonitor ? spreadStatus + (spreadWarning ? " ‚ö†Ô∏è" : "") : ""
        
        // Combine elements with separators
        contextParts = array.new<string>()
        if sessionText != ""
            contextParts.push(sessionText)
        if timerText != ""
            contextParts.push(timerText)
        if spreadText != ""
            contextParts.push(spreadText)
        
        // Join with separator
        string contextText = ""
        color contextColor = colorText
        if contextParts.size() > 0
            contextText := contextParts.get(0)
            for i = 1 to contextParts.size() - 1
                contextText += " ‚îÇ " + contextParts.get(i)
            // Use timer color if timer is in warning state
            if showBarTimer and minutesRemaining <= barTimerWarning and minutesRemaining > barTimerCritical
                contextColor := barTimerColor
        
        if contextText != ""
            table.cell(dashTable, 0, row, contextText, 
                 text_color=contextColor, 
                 text_size=dataSize, 
                 bgcolor=color.new(colorBody, panelTransparency),
                 text_halign=text.align_center)
            table.cell(dashTable, 1, row, "", 
                 bgcolor=color.new(colorBody, panelTransparency))
            row += 1
        
        // ========================================
        // TIER 3: STANDARD MODE (NEW DAY 3)
        // ========================================
        
        if displayMode == "Standard" or displayMode == "Full"
            // Score Breakdown Section (NEW)
            table.cell(dashTable, 0, row, "SCORE BREAKDOWN", 
                 text_color=colorText, 
                 text_size=headerSize, 
                 bgcolor=color.new(colorHeader, panelTransparency),
                 text_halign=text.align_center)
            table.cell(dashTable, 1, row, "", 
                 bgcolor=color.new(colorHeader, panelTransparency))
            row += 1
            
            // Trend component
            table.cell(dashTable, 0, row, "Trend Quality", 
                 text_color=colorText, 
                 text_size=dataSize, 
                 bgcolor=color.new(colorBody, panelTransparency),
                 text_halign=text.align_left)
            table.cell(dashTable, 1, row, str.tostring(math.round(trendQualityScore)) + "/40", 
                 text_color=colorText, 
                 text_size=dataSize, 
                 bgcolor=color.new(colorBody, panelTransparency),
                 text_halign=text.align_right)
            row += 1
            
            // Volatility component
            table.cell(dashTable, 0, row, "Volatility Regime", 
                 text_color=colorText, 
                 text_size=dataSize, 
                 bgcolor=color.new(colorBody, panelTransparency),
                 text_halign=text.align_left)
            table.cell(dashTable, 1, row, str.tostring(math.round(volatilityScore)) + "/30", 
                 text_color=colorText, 
                 text_size=scoreSize, 
                 bgcolor=color.new(colorBody, panelTransparency),
                 text_halign=text.align_right)
            row += 1
            
            // Momentum component
            table.cell(dashTable, 0, row, "Momentum Alignment", 
                 text_color=colorText, 
                 text_size=dataSize, 
                 bgcolor=color.new(colorBody, panelTransparency),
                 text_halign=text.align_left)
            table.cell(dashTable, 1, row, str.tostring(math.round(momentumScore)) + "/20", 
                 text_color=colorText, 
                 text_size=scoreSize, 
                 bgcolor=color.new(colorBody, panelTransparency),
                 text_halign=text.align_right)
            row += 1
            
            // Risk component
            table.cell(dashTable, 0, row, "Risk Context", 
                 text_color=colorText, 
                 text_size=dataSize, 
                 bgcolor=color.new(colorBody, panelTransparency),
                 text_halign=text.align_left)
            table.cell(dashTable, 1, row, str.tostring(math.round(riskScore)) + "/4", 
                 text_color=colorText, 
                 text_size=scoreSize, 
                 bgcolor=color.new(colorBody, panelTransparency),
                 text_halign=text.align_right)
            row += 1
            
            // Price Action component
            table.cell(dashTable, 0, row, "Price Action", 
                 text_color=colorText, 
                 text_size=dataSize, 
                 bgcolor=color.new(colorBody, panelTransparency),
                 text_halign=text.align_left)
            table.cell(dashTable, 1, row, str.tostring(math.round(priceActionScore)) + "/4", 
                 text_color=colorText, 
                 text_size=scoreSize, 
                 bgcolor=color.new(colorBody, panelTransparency),
                 text_halign=text.align_right)
            row += 1
            
            // Volatility Analysis Section
            table.cell(dashTable, 0, row, "VOLATILITY ANALYSIS", 
                 text_color=colorText, 
                 text_size=headerSize, 
                 bgcolor=color.new(colorHeader, panelTransparency),
                 text_halign=text.align_center)
            table.cell(dashTable, 1, row, "", 
                 bgcolor=color.new(colorHeader, panelTransparency))
            row += 1
            
            // State and explanation
            table.cell(dashTable, 0, row, "State: " + atrState, 
                 text_color=colorText, 
                 text_size=dataSize, 
                 bgcolor=color.new(colorBody, panelTransparency),
                 text_halign=text.align_left)
            table.cell(dashTable, 1, row, str.tostring(math.round(atrPercentile)) + "%ile", 
                 text_color=colorText, 
                 text_size=dataSize, 
                 bgcolor=color.new(colorBody, panelTransparency),
                 text_halign=text.align_right)
            row += 1
            
            table.cell(dashTable, 0, row, volExplanation, 
                 text_color=colorText, 
                 text_size=dataSize, 
                 bgcolor=color.new(colorBody, panelTransparency),
                 text_halign=text.align_left)
            table.cell(dashTable, 1, row, "", 
                 bgcolor=color.new(colorBody, panelTransparency))
            row += 1
            
            // Risk Management Section
            table.cell(dashTable, 0, row, "RISK MANAGEMENT", 
                 text_color=colorText, 
                 text_size=headerSize, 
                 bgcolor=color.new(colorHeader, panelTransparency),
                 text_halign=text.align_center)
            table.cell(dashTable, 1, row, "", 
                 bgcolor=color.new(colorHeader, panelTransparency))
            row += 1
            
            // Stop level
            table.cell(dashTable, 0, row, "Stop", 
                 text_color=colorText, 
                 text_size=dataSize, 
                 bgcolor=color.new(colorBody, panelTransparency),
                 text_halign=text.align_left)
            table.cell(dashTable, 1, row, str.tostring(stopLevel, "#.####") + " (" + str.tostring(stopPips) + " pips)", 
                 text_color=colorText, 
                 text_size=dataSize, 
                 bgcolor=color.new(colorBody, panelTransparency),
                 text_halign=text.align_right)
            row += 1
            
            // Target level
            table.cell(dashTable, 0, row, "Target", 
                 text_color=colorText, 
                 text_size=dataSize, 
                 bgcolor=color.new(colorBody, panelTransparency),
                 text_halign=text.align_left)
            table.cell(dashTable, 1, row, str.tostring(targetLevel, "#.####") + " (" + str.tostring(targetPips) + " pips)", 
                 text_color=colorText, 
                 text_size=dataSize, 
                 bgcolor=color.new(colorBody, panelTransparency),
                 text_halign=text.align_right)
            row += 1
            
            // R:R
            table.cell(dashTable, 0, row, "R:R Ratio", 
                 text_color=colorText, 
                 text_size=dataSize, 
                 bgcolor=color.new(colorBody, panelTransparency),
                 text_halign=text.align_left)
            table.cell(dashTable, 1, row, str.tostring(riskReward, "#.#") + ":1", 
                 text_color=riskReward >= 2.0 ? colorPass : riskReward >= 1.5 ? colorText : colorFail, 
                 text_size=dataSize, 
                 bgcolor=color.new(colorBody, panelTransparency),
                 text_halign=text.align_right)
            row += 1
            
            // Trend Details Section
            table.cell(dashTable, 0, row, "TREND DETAILS", 
                 text_color=colorText, 
                 text_size=headerSize, 
                 bgcolor=color.new(colorHeader, panelTransparency),
                 text_halign=text.align_center)
            table.cell(dashTable, 1, row, "", 
                 bgcolor=color.new(colorHeader, panelTransparency))
            row += 1
            
            // EMA structure
            table.cell(dashTable, 0, row, trendExplanation, 
                 text_color=colorText, 
                 text_size=dataSize, 
                 bgcolor=color.new(colorBody, panelTransparency),
                 text_halign=text.align_left)
            table.cell(dashTable, 1, row, "", 
                 bgcolor=color.new(colorBody, panelTransparency))
            row += 1
            
            // ADX
            table.cell(dashTable, 0, row, "ADX", 
                 text_color=colorText, 
                 text_size=dataSize, 
                 bgcolor=color.new(colorBody, panelTransparency),
                 text_halign=text.align_left)
            table.cell(dashTable, 1, row, str.tostring(math.round(adxValue)) + " (" + adxInterpretation + ")", 
                 text_color=adxValue > adxThreshold ? colorPass : colorFail, 
                 text_size=dataSize, 
                 bgcolor=color.new(colorBody, panelTransparency),
                 text_halign=text.align_right)
            row += 1
            
            // HTF trend
            htfText = mtfAlignmentBullish ? "BULLISH ‚úì" : mtfBearCount == 3 ? "BEARISH ‚úì" : "MIXED"
            table.cell(dashTable, 0, row, "HTF Bias", 
                 text_color=colorText, 
                 text_size=dataSize, 
                 bgcolor=color.new(colorBody, panelTransparency),
                 text_halign=text.align_left)
            table.cell(dashTable, 1, row, htfText, 
                 text_color=mtfFullAlignment ? colorPass : colorFail, 
                 text_size=dataSize, 
                 bgcolor=color.new(colorBody, panelTransparency),
                 text_halign=text.align_right)
            row += 1
            
            // S/R PROXIMITY SECTION (NEW DAY 4)
            table.cell(dashTable, 0, row, "S/R PROXIMITY", 
                 text_color=colorText, 
                 text_size=headerSize, 
                 bgcolor=color.new(colorHeader, panelTransparency),
                 text_halign=text.align_center)
            table.cell(dashTable, 1, row, "", 
                 bgcolor=color.new(colorHeader, panelTransparency))
            row += 1
            
            // Distance to resistance
            table.cell(dashTable, 0, row, "To Resistance", 
                 text_color=colorText, 
                 text_size=dataSize, 
                 bgcolor=color.new(colorBody, panelTransparency),
                 text_halign=text.align_left)
            table.cell(dashTable, 1, row, str.tostring(distToResistance, "#.##") + " ATR", 
                 text_color=distToResistance < 0.5 ? colorFail : distToResistance < 1.5 ? colorText : colorPass, 
                 text_size=dataSize, 
                 bgcolor=color.new(colorBody, panelTransparency),
                 text_halign=text.align_right)
            row += 1
            
            // Distance to support
            table.cell(dashTable, 0, row, "To Support", 
                 text_color=colorText, 
                 text_size=dataSize, 
                 bgcolor=color.new(colorBody, panelTransparency),
                 text_halign=text.align_left)
            table.cell(dashTable, 1, row, str.tostring(distToSupport, "#.##") + " ATR", 
                 text_color=distToSupport < 0.5 ? colorFail : distToSupport < 1.5 ? colorText : colorPass, 
                 text_size=dataSize, 
                 bgcolor=color.new(colorBody, panelTransparency),
                 text_halign=text.align_right)
            row += 1
            
            // S/R Status
            table.cell(dashTable, 0, row, "S/R Status", 
                 text_color=colorText, 
                 text_size=dataSize, 
                 bgcolor=color.new(colorBody, panelTransparency),
                 text_halign=text.align_left)
            table.cell(dashTable, 1, row, srStatus, 
                 text_color=srStatusColor, 
                 text_size=dataSize, 
                 bgcolor=color.new(colorBody, panelTransparency),
                 text_halign=text.align_right)
            row += 1
            
            // ENTRY ZONE ANALYSIS SECTION (NEW DAY 4)
            table.cell(dashTable, 0, row, "ENTRY ZONE ANALYSIS", 
                 text_color=colorText, 
                 text_size=headerSize, 
                 bgcolor=color.new(colorHeader, panelTransparency),
                 text_halign=text.align_center)
            table.cell(dashTable, 1, row, "", 
                 bgcolor=color.new(colorHeader, panelTransparency))
            row += 1
            
            // EMA Distance
            table.cell(dashTable, 0, row, "EMA Distance", 
                 text_color=colorText, 
                 text_size=dataSize, 
                 bgcolor=color.new(colorBody, panelTransparency),
                 text_halign=text.align_left)
            table.cell(dashTable, 1, row, str.tostring(distFromFastEMA, "#.##") + " ATR", 
                 text_color=entryZoneColor, 
                 text_size=dataSize, 
                 bgcolor=color.new(colorBody, panelTransparency),
                 text_halign=text.align_right)
            row += 1
            
            // Entry Zone Quality
            table.cell(dashTable, 0, row, "Entry Zone", 
                 text_color=colorText, 
                 text_size=dataSize, 
                 bgcolor=color.new(colorBody, panelTransparency),
                 text_halign=text.align_left)
            table.cell(dashTable, 1, row, entryZoneQuality, 
                 text_color=entryZoneColor, 
                 text_size=dataSize, 
                 bgcolor=color.new(colorBody, panelTransparency),
                 text_halign=text.align_right)
            row += 1
            
            // RSI Momentum Status
            table.cell(dashTable, 0, row, "RSI Momentum", 
                 text_color=colorText, 
                 text_size=dataSize, 
                 bgcolor=color.new(colorBody, panelTransparency),
                 text_halign=text.align_left)
            table.cell(dashTable, 1, row, rsiMomentumStatus, 
                 text_color=rsiMomentumBonus >= 2.0 ? colorPass : rsiMomentumBonus >= 1.0 ? colorText : color.gray, 
                 text_size=dataSize, 
                 bgcolor=color.new(colorBody, panelTransparency),
                 text_halign=text.align_right)
            row += 1
            
            // Entry Total Score
            table.cell(dashTable, 0, row, "Entry Score", 
                 text_color=colorText, 
                 text_size=dataSize, 
                 bgcolor=color.new(colorBody, panelTransparency),
                 text_halign=text.align_left)
            table.cell(dashTable, 1, row, str.tostring(entryTotalScore, "#.#") + "/7 (" + entryRating + ")", 
                 text_color=entryTotalScore >= 6 ? colorPass : entryTotalScore >= 4 ? colorText : colorFail, 
                 text_size=dataSize, 
                 bgcolor=color.new(colorBody, panelTransparency),
                 text_halign=text.align_right)
            row += 1
        
        // ========================================
        // TIER 4: FULL MODE (NEW DAY 3)
        // ========================================
        
        if displayMode == "Full"
            // Momentum Section
            table.cell(dashTable, 0, row, "MOMENTUM (RSI)", 
                 text_color=colorText, 
                 text_size=headerSize, 
                 bgcolor=color.new(colorHeader, panelTransparency),
                 text_halign=text.align_center)
            table.cell(dashTable, 1, row, "", 
                 bgcolor=color.new(colorHeader, panelTransparency))
            row += 1
            
            // Current TF RSI
            table.cell(dashTable, 0, row, "Current TF", 
                 text_color=colorText, 
                 text_size=dataSize, 
                 bgcolor=color.new(colorBody, panelTransparency),
                 text_halign=text.align_left)
            table.cell(dashTable, 1, row, str.tostring(math.round(rsiCurrent)), 
                 text_color=rsiCurrent > 50 ? colorPass : colorFail, 
                 text_size=dataSize, 
                 bgcolor=color.new(colorBody, panelTransparency),
                 text_halign=text.align_right)
            row += 1
            
            // H1 RSI
            table.cell(dashTable, 0, row, "1H", 
                 text_color=colorText, 
                 text_size=dataSize, 
                 bgcolor=color.new(colorBody, panelTransparency),
                 text_halign=text.align_left)
            table.cell(dashTable, 1, row, str.tostring(math.round(rsiH1)), 
                 text_color=rsiH1 > 50 ? colorPass : colorFail, 
                 text_size=dataSize, 
                 bgcolor=color.new(colorBody, panelTransparency),
                 text_halign=text.align_right)
            row += 1
            
            // H4 RSI
            table.cell(dashTable, 0, row, "4H", 
                 text_color=colorText, 
                 text_size=dataSize, 
                 bgcolor=color.new(colorBody, panelTransparency),
                 text_halign=text.align_left)
            table.cell(dashTable, 1, row, str.tostring(math.round(rsiH4)), 
                 text_color=rsiH4 > 50 ? colorPass : colorFail, 
                 text_size=dataSize, 
                 bgcolor=color.new(colorBody, panelTransparency),
                 text_halign=text.align_right)
            row += 1
            
            // Daily RSI
            table.cell(dashTable, 0, row, "Daily", 
                 text_color=colorText, 
                 text_size=dataSize, 
                 bgcolor=color.new(colorBody, panelTransparency),
                 text_halign=text.align_left)
            table.cell(dashTable, 1, row, str.tostring(math.round(rsiD1)), 
                 text_color=rsiD1 > 50 ? colorPass : colorFail, 
                 text_size=dataSize, 
                 bgcolor=color.new(colorBody, panelTransparency),
                 text_halign=text.align_right)
            row += 1
            
            // RSI Alignment summary
            rsiSummary = rsiAllBull ? "All BULL ‚úì" : rsiAllBear ? "All BEAR ‚úì" : str.tostring(rsiBullCount) + "/4 Bull"
            table.cell(dashTable, 0, row, "Alignment", 
                 text_color=colorText, 
                 text_size=dataSize, 
                 bgcolor=color.new(colorBody, panelTransparency),
                 text_halign=text.align_left)
            table.cell(dashTable, 1, row, rsiSummary, 
                 text_color=(rsiAllBull or rsiAllBear) ? colorPass : colorText, 
                 text_size=dataSize, 
                 bgcolor=color.new(colorBody, panelTransparency),
                 text_halign=text.align_right)
            row += 1
            
            // Price Action Section
            table.cell(dashTable, 0, row, "PRICE ACTION", 
                 text_color=colorText, 
                 text_size=headerSize, 
                 bgcolor=color.new(colorHeader, panelTransparency),
                 text_halign=text.align_center)
            table.cell(dashTable, 1, row, "", 
                 bgcolor=color.new(colorHeader, panelTransparency))
            row += 1
            
            // Daily range position
            table.cell(dashTable, 0, row, "Daily Range", 
                 text_color=colorText, 
                 text_size=dataSize, 
                 bgcolor=color.new(colorBody, panelTransparency),
                 text_halign=text.align_left)
            rangeText = str.tostring(math.round(dailyPosition)) + "%"
            rangeColor = dailyPosition >= 40 and dailyPosition <= 60 ? colorPass : colorText
            table.cell(dashTable, 1, row, rangeText, 
                 text_color=rangeColor, 
                 text_size=dataSize, 
                 bgcolor=color.new(colorBody, panelTransparency),
                 text_halign=text.align_right)
            row += 1
            
            // Spread detail
            table.cell(dashTable, 0, row, "Spread Status", 
                 text_color=colorText, 
                 text_size=dataSize, 
                 bgcolor=color.new(colorBody, panelTransparency),
                 text_halign=text.align_left)
            table.cell(dashTable, 1, row, spreadStatus + (spreadWarning ? " ‚ö†Ô∏è" : ""), 
                 text_color=spreadWarning ? colorFail : colorPass, 
                 text_size=dataSize, 
                 bgcolor=color.new(colorBody, panelTransparency),
                 text_halign=text.align_right)
            row += 1

// ============================================================================
// ALERT QUALITY FILTER CHECKS (NEW v1.5)
// ============================================================================

// Entry Zone filter
entryIsHotOrOptimal = str.contains(entryZoneQuality, "HOT") or str.contains(entryZoneQuality, "OPTIMAL")
entryIncludesAcceptable = entryIsHotOrOptimal or str.contains(entryZoneQuality, "ACCEPTABLE")
entryPassesForStrong = strongEntryRequirement == "Any Zone" ? true : strongEntryRequirement == "Include ACCEPTABLE" ? entryIncludesAcceptable : entryIsHotOrOptimal

// S/R Proximity filter (new!)
srProximityPasses = distToNearestSR >= srProximityFilter

// Score gap filter (new!)
scoreGapPassesStrong = overallScore >= (alertStrongThreshold + scoreGapRequired)
scoreGapPassesPerfect = overallScore >= (alertPerfectThreshold + scoreGapRequired)

// Combined quality filters
qualityFiltersPassed = entryPassesForStrong and srProximityPasses

// ============================================================================
// CANDIDATE CONDITION (v2.0) - Elite early heads-up, intra-bar capable
// ============================================================================
// CANDIDATE is tighter than ARMED: requires HOT/OPTIMAL, higher score threshold
// Does NOT require persistence or session lock - fires on first sight of quality
candidateMeetsLong = allCriteriaMet and mtfAlignCount == 3 and trendDirection == 1 and entryIsHotOrOptimal and srProximityPasses and overallScore >= candidateThreshold
candidateMeetsShort = allCriteriaMet and mtfAlignCount == 3 and trendDirection == -1 and entryIsHotOrOptimal and srProximityPasses and overallScore >= candidateThreshold
candidateMeets = candidateMeetsLong or candidateMeetsShort
candidateDirection = candidateMeetsLong ? 1 : candidateMeetsShort ? -1 : 0

// CANDIDATE state transitions (intra-bar capable - uses realtime memory)
contextJustCandidateLong = candidateMeetsLong and (not wasCandidate_rt or wasCandidateDir_rt != 1)
contextJustCandidateShort = candidateMeetsShort and (not wasCandidate_rt or wasCandidateDir_rt != -1)
contextJustCandidate = contextJustCandidateLong or contextJustCandidateShort

// Update realtime memory immediately (prevents intra-bar spam)
wasCandidate_rt := candidateMeets
wasCandidateDir_rt := candidateDirection

// Update confirmed memory on bar close (for diagnostics)
if barstate.isconfirmed
    wasCandidate_close := candidateMeets

// ============================================================================
// ALERT DIAGNOSTICS PANEL (v2.1 - Alert Timing Visibility)
// ============================================================================
// Shows real-time status of context armed/disarmed state
// Helps identify exactly which condition is blocking or triggering alerts

var table diagTable = na

// Pre-calculate diagnostic values
diagCriteriaMetCount = (criterion1Pass ? 1 : 0) + (criterion2Pass ? 1 : 0) + 
     (criterion3Pass ? 1 : 0) + (criterion4Pass ? 1 : 0)
diagEntryHotOpt = str.contains(entryZoneQuality, "HOT") or str.contains(entryZoneQuality, "OPTIMAL")
diagEntryAcceptable = diagEntryHotOpt or str.contains(entryZoneQuality, "ACCEPTABLE")
diagEntryOK = strongEntryRequirement == "Any Zone" ? true : strongEntryRequirement == "Include ACCEPTABLE" ? diagEntryAcceptable : diagEntryHotOpt
diagMTFOK = mtfAlignCount == 3
diagIsBull = trendDirection == 1
diagIsBear = trendDirection == -1
diagTimerOK = minutesRemaining > barTimerCritical

// Create diagnostic table
if barstate.isfirst and showAlertDiagnostics
    diagTable := table.new(position.bottom_left, 2, 19,
         bgcolor=color.new(color.rgb(30, 30, 40), 10),
         frame_color=color.rgb(100, 100, 120),
         frame_width=1,
         border_width=1,
         border_color=color.rgb(60, 60, 80))

// Draw diagnostic panel
if barstate.islast and showAlertDiagnostics
    table.clear(diagTable, 0, 0, 1, 18)
    
    dRow = 0
    diagSize = size.small
    
    // Header
    table.cell(diagTable, 0, dRow, "v2.5 DIAGNOSTICS", 
         text_color=color.white, text_size=size.normal,
         bgcolor=color.rgb(80, 80, 100), text_halign=text.align_center)
    table.cell(diagTable, 1, dRow, currentSession, 
         text_color=color.yellow, text_size=size.normal,
         bgcolor=color.rgb(80, 80, 100), text_halign=text.align_right)
    dRow += 1
    
    // === CURRENT STATE ===
    table.cell(diagTable, 0, dRow, "‚îÄ‚îÄ‚îÄ CURRENT STATE ‚îÄ‚îÄ‚îÄ", 
         text_color=color.gray, text_size=diagSize,
         bgcolor=color.rgb(40, 40, 50), text_halign=text.align_center)
    table.cell(diagTable, 1, dRow, "", bgcolor=color.rgb(40, 40, 50))
    dRow += 1
    
    // Armed Status (main indicator)
    armedDisplayText = isArmed ? (armedDirection == 1 ? "‚Üë ARMED" : "‚Üì ARMED") : "DISARMED"
    armedDisplayColor = isArmed ? color.rgb(34, 197, 94) : color.rgb(239, 68, 68)
    table.cell(diagTable, 0, dRow, "Context State", 
         text_color=color.white, text_size=diagSize,
         bgcolor=color.rgb(30, 30, 40), text_halign=text.align_left)
    table.cell(diagTable, 1, dRow, armedDisplayText, 
         text_color=armedDisplayColor, text_size=size.normal,
         bgcolor=color.rgb(30, 30, 40), text_halign=text.align_right)
    dRow += 1
    
    // Playbook
    table.cell(diagTable, 0, dRow, "Playbook", 
         text_color=color.white, text_size=diagSize,
         bgcolor=color.rgb(30, 30, 40), text_halign=text.align_left)
    table.cell(diagTable, 1, dRow, currentPlaybook, 
         text_color=color.rgb(100, 181, 246), text_size=diagSize,
         bgcolor=color.rgb(30, 30, 40), text_halign=text.align_right)
    dRow += 1
    
    // Session Lock
    lockStatusText = enableSessionLock ? (isArmed ? "LOCKED ‚Üë‚Üì" : "SEEKING") : "DISABLED"
    lockStatusColor = enableSessionLock ? (isArmed ? color.rgb(34, 197, 94) : color.rgb(234, 179, 8)) : color.gray
    table.cell(diagTable, 0, dRow, "Session Lock", 
         text_color=color.white, text_size=diagSize,
         bgcolor=color.rgb(30, 30, 40), text_halign=text.align_left)
    table.cell(diagTable, 1, dRow, lockStatusText, 
         text_color=lockStatusColor, text_size=diagSize,
         bgcolor=color.rgb(30, 30, 40), text_halign=text.align_right)
    dRow += 1
    
    // === ARM CONDITIONS ===
    table.cell(diagTable, 0, dRow, "‚îÄ‚îÄ‚îÄ ARM CONDITIONS ‚îÄ‚îÄ‚îÄ", 
         text_color=color.gray, text_size=diagSize,
         bgcolor=color.rgb(40, 40, 50), text_halign=text.align_center)
    table.cell(diagTable, 1, dRow, "", bgcolor=color.rgb(40, 40, 50))
    dRow += 1
    
    // Score vs Threshold
    scoreOK = overallScore >= alertStrongThreshold
    table.cell(diagTable, 0, dRow, "Score ‚â•" + str.tostring(alertStrongThreshold), 
         text_color=color.white, text_size=diagSize,
         bgcolor=color.rgb(30, 30, 40), text_halign=text.align_left)
    table.cell(diagTable, 1, dRow, str.tostring(math.round(overallScore)) + " " + (scoreOK ? "‚úÖ" : "‚ùå"), 
         text_color=scoreOK ? color.rgb(34, 171, 148) : color.rgb(239, 83, 80),
         text_size=diagSize, bgcolor=color.rgb(30, 30, 40), text_halign=text.align_right)
    dRow += 1
    
    // MTF Alignment
    table.cell(diagTable, 0, dRow, "MTF 3/3", 
         text_color=color.white, text_size=diagSize,
         bgcolor=color.rgb(30, 30, 40), text_halign=text.align_left)
    table.cell(diagTable, 1, dRow, str.tostring(mtfAlignCount) + "/3 " + (diagMTFOK ? "‚úÖ" : "‚ùå"), 
         text_color=diagMTFOK ? color.rgb(34, 171, 148) : color.rgb(239, 83, 80),
         text_size=diagSize, bgcolor=color.rgb(30, 30, 40), text_halign=text.align_right)
    dRow += 1
    
    // Direction
    dirText = diagIsBull ? "‚Üë BULL" : diagIsBear ? "‚Üì BEAR" : "MIXED"
    dirOK = diagIsBull or diagIsBear
    table.cell(diagTable, 0, dRow, "Direction", 
         text_color=color.white, text_size=diagSize,
         bgcolor=color.rgb(30, 30, 40), text_halign=text.align_left)
    table.cell(diagTable, 1, dRow, dirText + " " + (dirOK ? "‚úÖ" : "‚ùå"), 
         text_color=dirOK ? color.rgb(34, 171, 148) : color.rgb(239, 83, 80),
         text_size=diagSize, bgcolor=color.rgb(30, 30, 40), text_halign=text.align_right)
    dRow += 1
    
    // Entry Zone
    entryShortDiag = str.contains(entryZoneQuality, "HOT") ? "HOT" : str.contains(entryZoneQuality, "OPTIMAL") ? "OPT" : str.contains(entryZoneQuality, "ACCEPTABLE") ? "ACC" : str.contains(entryZoneQuality, "DEEP") ? "DEEP" : "EXT"
    table.cell(diagTable, 0, dRow, "Entry Zone", 
         text_color=color.white, text_size=diagSize,
         bgcolor=color.rgb(30, 30, 40), text_halign=text.align_left)
    table.cell(diagTable, 1, dRow, entryShortDiag + " " + (diagEntryOK ? "‚úÖ" : "‚ùå"), 
         text_color=diagEntryOK ? color.rgb(34, 171, 148) : color.rgb(239, 83, 80),
         text_size=diagSize, bgcolor=color.rgb(30, 30, 40), text_halign=text.align_right)
    dRow += 1
    
    // Efficiency
    effOK = rawEfficiency >= efficiencyThreshold
    table.cell(diagTable, 0, dRow, "Efficiency ‚â•" + str.tostring(math.round(efficiencyThreshold * 100)) + "%", 
         text_color=color.white, text_size=diagSize,
         bgcolor=color.rgb(30, 30, 40), text_halign=text.align_left)
    table.cell(diagTable, 1, dRow, str.tostring(math.round(rawEfficiency * 100)) + "% " + (effOK ? "‚úÖ" : "‚ùå"), 
         text_color=effOK ? color.rgb(34, 171, 148) : color.rgb(239, 83, 80),
         text_size=diagSize, bgcolor=color.rgb(30, 30, 40), text_halign=text.align_right)
    dRow += 1
    
    // Persistence (bars above threshold required before arming)
    persistOK = barsAboveThreshold >= upgradePersistence
    table.cell(diagTable, 0, dRow, "Persistence", 
         text_color=color.white, text_size=diagSize,
         bgcolor=color.rgb(30, 30, 40), text_halign=text.align_left)
    table.cell(diagTable, 1, dRow, str.tostring(barsAboveThreshold) + "/" + str.tostring(upgradePersistence) + " " + (persistOK ? "‚úÖ" : "‚è≥"), 
         text_color=persistOK ? color.rgb(34, 171, 148) : color.rgb(234, 179, 8),
         text_size=diagSize, bgcolor=color.rgb(30, 30, 40), text_halign=text.align_right)
    dRow += 1
    
    // === DISARM CONDITIONS ===
    table.cell(diagTable, 0, dRow, "‚îÄ‚îÄ‚îÄ DISARM TRIGGERS ‚îÄ‚îÄ‚îÄ", 
         text_color=color.gray, text_size=diagSize,
         bgcolor=color.rgb(40, 40, 50), text_halign=text.align_center)
    table.cell(diagTable, 1, dRow, "", bgcolor=color.rgb(40, 40, 50))
    dRow += 1
    
    // Score Drop (for disarm)
    scoreDropped = isArmed and (overallScore < (armedScore - disarmScoreThreshold))
    table.cell(diagTable, 0, dRow, "Score Drop >" + str.tostring(disarmScoreThreshold), 
         text_color=color.white, text_size=diagSize,
         bgcolor=color.rgb(30, 30, 40), text_halign=text.align_left)
    table.cell(diagTable, 1, dRow, scoreDropped ? "YES ‚ö†Ô∏è" : "NO ‚úì", 
         text_color=scoreDropped ? color.rgb(239, 83, 80) : color.rgb(100, 100, 120),
         text_size=diagSize, bgcolor=color.rgb(30, 30, 40), text_halign=text.align_right)
    dRow += 1
    
    // Structural Damage (uses existing structuralDamage variable from session lock logic)
    table.cell(diagTable, 0, dRow, "Structural Damage", 
         text_color=color.white, text_size=diagSize,
         bgcolor=color.rgb(30, 30, 40), text_halign=text.align_left)
    table.cell(diagTable, 1, dRow, structuralDamage ? "YES ‚ö†Ô∏è" : "NO ‚úì", 
         text_color=structuralDamage ? color.rgb(239, 83, 80) : color.rgb(100, 100, 120),
         text_size=diagSize, bgcolor=color.rgb(30, 30, 40), text_halign=text.align_right)
    dRow += 1
    
    // === ALERT WOULD FIRE ===
    table.cell(diagTable, 0, dRow, "‚îÄ‚îÄ‚îÄ ALERT STATUS ‚îÄ‚îÄ‚îÄ", 
         text_color=color.gray, text_size=diagSize,
         bgcolor=color.rgb(40, 40, 50), text_halign=text.align_center)
    table.cell(diagTable, 1, dRow, "", bgcolor=color.rgb(40, 40, 50))
    dRow += 1
    
    // State change detection
    wouldArmLong = not wasArmed and isArmed and armedDirection == 1
    wouldArmShort = not wasArmed and isArmed and armedDirection == -1
    wouldDisarm = wasArmed and not isArmed
    
    alertWouldFire = wouldArmLong or wouldArmShort or wouldDisarm
    
    // v2.1: Bar Confirmed status - shows when ARMED/DISARMED alerts will actually fire
    diagConfirmed = barstate.isconfirmed
    table.cell(diagTable, 0, dRow, "Bar Confirmed", 
         text_color=color.white, text_size=diagSize,
         bgcolor=color.rgb(30, 30, 40), text_halign=text.align_left)
    table.cell(diagTable, 1, dRow, diagConfirmed ? "‚úì YES" : "‚è≥ PENDING", 
         text_color=diagConfirmed ? color.rgb(34, 197, 94) : color.rgb(234, 179, 8), text_size=diagSize,
         bgcolor=color.rgb(30, 30, 40), text_halign=text.align_right)
    dRow += 1
    
    // v2.1: Show "at close" when transition detected but bar not confirmed
    string alertTypeText = na
    if alertWouldFire and not diagConfirmed
        alertTypeText := wouldArmLong ? "ARMED LONG (close)" : wouldArmShort ? "ARMED SHORT (close)" : "BLOCKED (close)"
    else if alertWouldFire and diagConfirmed
        alertTypeText := wouldArmLong ? "ARMED LONG" : wouldArmShort ? "ARMED SHORT" : "BLOCKED"
    else
        alertTypeText := "NO CHANGE"
    alertTypeColor = wouldArmLong or wouldArmShort ? color.rgb(34, 197, 94) : wouldDisarm ? color.rgb(239, 83, 80) : color.gray
    
    table.cell(diagTable, 0, dRow, "ARMED Would Fire", 
         text_color=color.white, text_size=diagSize,
         bgcolor=color.rgb(30, 30, 40), text_halign=text.align_left)
    table.cell(diagTable, 1, dRow, alertTypeText, 
         text_color=alertTypeColor, text_size=diagSize,
         bgcolor=color.rgb(30, 30, 40), text_halign=text.align_right)
    dRow += 1
    
    // CANDIDATE status (v2.0)
    candidateText = contextJustCandidateLong ? "CANDIDATE LONG" : contextJustCandidateShort ? "CANDIDATE SHORT" : candidateMeets ? "ACTIVE" : "NO"
    candidateColor = contextJustCandidate ? color.rgb(234, 179, 8) : candidateMeets ? color.rgb(100, 149, 237) : color.gray
    table.cell(diagTable, 0, dRow, "CANDIDATE Would Fire", 
         text_color=color.white, text_size=diagSize,
         bgcolor=color.rgb(30, 30, 40), text_halign=text.align_left)
    table.cell(diagTable, 1, dRow, candidateText, 
         text_color=candidateColor, text_size=diagSize,
         bgcolor=color.rgb(30, 30, 40), text_halign=text.align_right)

// Alert Condition: üî• STRONG BULLISH SETUP
// Primary bullish signal - High quality without RSI requirement
// v1.8: Alert conditions respect session lock when enabled
lockPassesLong = enableSessionLock ? (isArmed and armedDirection == 1) : true
lockPassesShort = enableSessionLock ? (isArmed and armedDirection == -1) : true

strongBullishCondition = debugMode ? true : (allCriteriaMet and scoreGapPassesStrong and qualityFiltersPassed and mtfAlignCount == 3 and trendDirection == 1 and lockPassesLong)

// Alert Condition: üî• STRONG BEARISH SETUP
// Primary bearish signal - High quality without RSI requirement
strongBearishCondition = debugMode ? true : (allCriteriaMet and scoreGapPassesStrong and qualityFiltersPassed and mtfAlignCount == 3 and trendDirection == -1 and lockPassesShort)

// Alert Condition: üî• PERFECT BULLISH SETUP
// Ultimate bullish setup - All conditions + RSI MTF alignment (always requires HOT/OPTIMAL)
perfectBullishCondition = debugMode ? true : (allCriteriaMet and scoreGapPassesPerfect and entryIsHotOrOptimal and srProximityPasses and mtfAlignCount == 3 and trendDirection == 1 and rsiAllBull and lockPassesLong)

// Alert Condition: üî• PERFECT BEARISH SETUP
// Ultimate bearish setup - All conditions + RSI MTF alignment (always requires HOT/OPTIMAL)
perfectBearishCondition = debugMode ? true : (allCriteriaMet and scoreGapPassesPerfect and entryIsHotOrOptimal and srProximityPasses and mtfAlignCount == 3 and trendDirection == -1 and rsiAllBear and lockPassesShort)

// ============================================================================
// ALERT CONDITION: MTF DEGRADATION (v1.6 - Open Trade Management)
// ============================================================================
// Fires when MTF conditions degrade - critical for managing open positions

// Track previous states
var int prev1HDirection = 0
var int prev4HDirection = 0
var int prevMTFAlignCount = 0
var float prevTrendScore = 0.0

// Current directions
h1Direction = mtf1Bullish ? 1 : -1
h4Direction = mtf2Bullish ? 1 : -1

// Detect degradation
h1DirectionFlip = prev1HDirection != 0 and h1Direction != prev1HDirection and barstate.isconfirmed
h4DirectionFlip = prev4HDirection != 0 and h4Direction != prev4HDirection and barstate.isconfirmed
h4ScoreDrop = prevTrendScore >= mtfDegradationScoreThreshold and trendScore < mtfDegradationScoreThreshold and barstate.isconfirmed
mtfAlignmentBreak = prevMTFAlignCount == 3 and mtfAlignCount < 3 and barstate.isconfirmed

// Combined condition
mtfDegradationCondition = h1DirectionFlip or h4DirectionFlip or h4ScoreDrop or mtfAlignmentBreak

// What degraded (for reference)
degradationType = h4DirectionFlip ? "4H FLIP" : h4ScoreDrop ? "4H SCORE" : mtfAlignmentBreak ? "MTF BREAK" : h1DirectionFlip ? "1H FLIP" : ""

// Update states
if barstate.isconfirmed
    prev1HDirection := h1Direction
    prev4HDirection := h4Direction
    prevMTFAlignCount := mtfAlignCount
    prevTrendScore := trendScore

// ============================================================================
// ALERT CONDITION: üö® RISK WARNING
// ============================================================================
// Fires when risk events occur - news/session/spread warnings
// Prevents entering during dangerous conditions

// Detect risk events
newsRiskDetected = newsRiskHigh and barstate.isconfirmed
sessionRiskDetected = (currentSession == "LON+NY") and barstate.isconfirmed
spreadSpikeDetected = spreadWarning and (currentSpread >= avgSpread * riskSpreadMultiplier) and barstate.isconfirmed

// Combined risk condition
riskWarningCondition = newsRiskDetected or sessionRiskDetected or spreadSpikeDetected

// Identify risk type
riskType = newsRiskDetected ? "NEWS RISK" :
     sessionRiskDetected ? "LON+NY OVERLAP" :
     spreadSpikeDetected ? "SPREAD SPIKE" : ""

// Build context
riskContext = newsRiskDetected ? str.tostring(newsBufferHours) + "h to news" :
     sessionRiskDetected ? "High volatility" :
     spreadSpikeDetected ? str.tostring(math.round(currentSpread / avgSpread * 10) / 10) + "x avg" : ""

// ============================================================================
// REGISTER ALERT CONDITIONS WITH TRADINGVIEW
// ============================================================================
// ============================================================================
// WATCHLIST ALERTS - PLAIN TEXT FORMAT FOR EMAIL/DISCORD
// ============================================================================
// ============================================================================
// MINIMAL ALERT TAXONOMY (v2.0) - State changes only
// ============================================================================
// Alerts are boring by design. No scores. No hype. Just state changes.
// Direction = contextual orientation only, not instruction.
// ‚Üë = Long context, ‚Üì = Short context
// 
// v2.0 ALERT HIERARCHY:
// 1. CANDIDATE (intra-bar) - Elite early heads-up. Not permission. Just watch.
// 2. ARMED (bar close) - Permission gate. May execute checklist.
// 3. DISARMED - Stop hunting. Manage open risk.
// 4. SESSION RESET - Fresh evaluation required.

// State change detection - uses PREVIOUS BAR values for clean one-time alerts
// wasArmed/wasArmedDirection/lastSession only update on bar CLOSE (see below)
// sessionJustChanged calculated earlier for unified usage (alerts + session lock)
// NOTE: CANDIDATE transitions are calculated earlier (uses realtime memory)
contextJustArmedLong = isArmed and armedDirection == 1 and (not wasArmed or wasArmedDirection != 1)
contextJustArmedShort = isArmed and armedDirection == -1 and (not wasArmed or wasArmedDirection != -1)
contextJustDisarmed = wasArmed and not isArmed

// Update state tracking ONLY on confirmed bar close (CRITICAL FIX)
// This guarantees clean FALSE‚ÜíTRUE transitions for alerts
if barstate.isconfirmed
    wasArmed := isArmed
    wasArmedDirection := armedDirection
    lastSession := currentSession


// v2.3.0: Short playbook for alerts (strips LONG/SHORT suffix)
playbookShort = str.contains(currentPlaybook, "CONTINUATION") ? "CONTINUATION" : str.contains(currentPlaybook, "DEEP PULLBACK") ? "DEEP PULLBACK" : str.contains(currentPlaybook, "OBSERVATION") ? "OBSERVATION" : str.contains(currentPlaybook, "STAND DOWN") ? "STAND DOWN" : "NO TRADE"

// v2.5.0: Old buildJsonPayload() removed ‚Äî replaced by f_buildAlert() + f_buildJson()
// v2.5.0: Chart link for JSON context
chartLink = "https://tradingview.com/chart/?symbol=OANDA:" + syminfo.ticker


// ALERT 0: Candidate (Long) - Quality detected, intra-bar
alertcondition(enableContextCandidate and contextJustCandidateLong, 
     title="CANDIDATE Long",
     message='üü° [C] CANDIDATE | {{ticker}} | R-TRANSITION | K-NORMAL | CONDITIONAL')

// ALERT 0: Candidate (Short) - Quality detected, intra-bar
alertcondition(enableContextCandidate and contextJustCandidateShort, 
     title="CANDIDATE Short",
     message='üü° [C] CANDIDATE | {{ticker}} | R-TRANSITION | K-NORMAL | CONDITIONAL')

// ALERT 1: Armed (Long) - Full permission, bar close confirmed
alertcondition(enableContextArmed and contextJustArmedLong and barstate.isconfirmed, 
     title="ARMED Long",
     message='üü¢ [A] ARMED | {{ticker}} | R-EXPANSION | K-NORMAL | FULL')

// ALERT 2: Armed (Short) - Full permission, bar close confirmed
alertcondition(enableContextArmed and contextJustArmedShort and barstate.isconfirmed, 
     title="ARMED Short",
     message='üü¢ [A] ARMED | {{ticker}} | R-EXPANSION | K-NORMAL | FULL')

// ALERT 3: Blocked - Explicit veto, bar close confirmed
alertcondition(enableContextDisarmed and contextJustDisarmed and barstate.isconfirmed, 
     title="BLOCKED",
     message='üî¥ [B] BLOCKED | {{ticker}} | R-COMPRESSION | STAND_DOWN')

// ALERT 4: Info - Session reset, context only
alertcondition(enableSessionReset and sessionResetEvent, 
     title="INFO Session Reset",
     message='‚ö™ [I] INFO | {{ticker}} | SESSION_RESET')

// ============================================================================
// INSTITUTIONAL ALERT DISPATCH (v2.5.0)
// ============================================================================
// Uses f_buildAlert() with resolved variables from Priority Resolver.
// Two-layer format: Scan line (triage) + JSON body (audit).
// All alerts use the 4-emoji standard. No exceptions.
// ============================================================================

// Derived context values for JSON payload
alertDirStr = trendDirection == 1 ? "long" : trendDirection == -1 ? "short" : "none"
alertEntryClean = str.contains(entryZoneQuality, "HOT") ? "HOT" : str.contains(entryZoneQuality, "OPTIMAL") ? "OPTIMAL" : str.contains(entryZoneQuality, "ACCEPTABLE") ? "ACCEPTABLE" : str.contains(entryZoneQuality, "DEEP") ? "DEEP" : "EXTENDED"
alertRsiCount = trendDirection == 1 ? rsiBullCount : rsiBearCount
alertRegimeClean = str.replace(regimeCode, "R-", "", 0)
alertRiskClean = riskGovernorState

// Execution values for JSON
alertExecMaxRisk = finalPermission == "STAND_DOWN" ? "NONE" : finalPermission == "CONDITIONAL" ? "0.25R" : "1.0R"
alertExecMaxTrades = finalPermission == "STAND_DOWN" ? 0 : finalPermission == "CONDITIONAL" ? 1 : 3
alertExecAdds = finalPermission == "FULL" ? "ENABLED" : "DISABLED"

// State change detection for unified alert dispatch
stateChanged = contextJustCandidateLong or contextJustCandidateShort or contextJustArmedLong or contextJustArmedShort or contextJustDisarmed or sessionResetEvent

useAlertPerBar = alertMode == "alert() per bar"
useAlertBarClose = alertMode == "alert() bar close"
alertFreq = useAlertBarClose ? alert.freq_once_per_bar_close : alert.freq_once_per_bar

if useAlertPerBar or useAlertBarClose
    // --- CANDIDATE (Long) ‚Äî intra-bar capable ---
    if enableContextCandidate and contextJustCandidateLong
        string candAlertType = finalPermission == "STAND_DOWN" ? ALERT_BLOCKED : ALERT_CANDIDATE
        string candExec = finalPermission == "STAND_DOWN" ? EXECUTION_NONE : EXECUTION_CONDITIONAL
        string candHeader = f_alertHeader(candAlertType, syminfo.ticker, primaryReason, riskCode, "U-SCORE-" + str.tostring(math.round(overallScore)))
        string candJson = f_buildJson(candAlertType, syminfo.ticker, "FX", primaryReason, contributingStr, finalPermission, alertExecMaxRisk, alertExecMaxTrades, alertExecAdds, alertDirStr, math.round(overallScore), criteriaMet, alertEntryClean, atrState, mtfAlignCount, alertRsiCount, currentSession, playbookShort, alertRegimeClean, alertRiskClean)
        alert(candHeader + "\n" + candJson, alert.freq_once_per_bar)
    
    // --- CANDIDATE (Short) ‚Äî intra-bar capable ---
    if enableContextCandidate and contextJustCandidateShort
        string candSAlertType = finalPermission == "STAND_DOWN" ? ALERT_BLOCKED : ALERT_CANDIDATE
        string candSExec = finalPermission == "STAND_DOWN" ? EXECUTION_NONE : EXECUTION_CONDITIONAL
        string candSHeader = f_alertHeader(candSAlertType, syminfo.ticker, primaryReason, riskCode, "U-SCORE-" + str.tostring(math.round(overallScore)))
        string candSJson = f_buildJson(candSAlertType, syminfo.ticker, "FX", primaryReason, contributingStr, finalPermission, alertExecMaxRisk, alertExecMaxTrades, alertExecAdds, alertDirStr, math.round(overallScore), criteriaMet, alertEntryClean, atrState, mtfAlignCount, alertRsiCount, currentSession, playbookShort, alertRegimeClean, alertRiskClean)
        alert(candSHeader + "\n" + candSJson, alert.freq_once_per_bar)
    
    // --- ARMED (Long) ‚Äî confirmed bar only ---
    if enableContextArmed and contextJustArmedLong and barstate.isconfirmed
        string armLHeader = f_alertHeader(resolvedAlertType, syminfo.ticker, primaryReason, riskCode, "U-SCORE-" + str.tostring(math.round(overallScore)))
        string armLJson = f_buildJson(resolvedAlertType, syminfo.ticker, "FX", primaryReason, contributingStr, finalPermission, alertExecMaxRisk, alertExecMaxTrades, alertExecAdds, alertDirStr, math.round(overallScore), criteriaMet, alertEntryClean, atrState, mtfAlignCount, alertRsiCount, currentSession, playbookShort, alertRegimeClean, alertRiskClean)
        alert(armLHeader + "\n" + armLJson, alertFreq)
    
    // --- ARMED (Short) ‚Äî confirmed bar only ---
    if enableContextArmed and contextJustArmedShort and barstate.isconfirmed
        string armSHeader = f_alertHeader(resolvedAlertType, syminfo.ticker, primaryReason, riskCode, "U-SCORE-" + str.tostring(math.round(overallScore)))
        string armSJson = f_buildJson(resolvedAlertType, syminfo.ticker, "FX", primaryReason, contributingStr, finalPermission, alertExecMaxRisk, alertExecMaxTrades, alertExecAdds, alertDirStr, math.round(overallScore), criteriaMet, alertEntryClean, atrState, mtfAlignCount, alertRsiCount, currentSession, playbookShort, alertRegimeClean, alertRiskClean)
        alert(armSHeader + "\n" + armSJson, alertFreq)
    
    // --- BLOCKED (was DISARMED) ‚Äî confirmed bar only ---
    if enableContextDisarmed and contextJustDisarmed and barstate.isconfirmed
        string blkHeader = f_alertHeader(ALERT_BLOCKED, syminfo.ticker, primaryReason, riskCode, "U-SCORE-" + str.tostring(math.round(overallScore)))
        string blkJson = f_buildJson(ALERT_BLOCKED, syminfo.ticker, "FX", primaryReason, contributingStr, "STAND_DOWN", "NONE", 0, "DISABLED", alertDirStr, math.round(overallScore), criteriaMet, alertEntryClean, atrState, mtfAlignCount, alertRsiCount, currentSession, playbookShort, alertRegimeClean, alertRiskClean)
        alert(blkHeader + "\n" + blkJson, alertFreq)
    
    // --- INFO: Session Reset ‚Äî one-shot event ---
    if enableSessionReset and sessionResetEvent
        string infoHeader = f_alertEmoji(ALERT_INFO) + " " + f_alertPrefix(ALERT_INFO) + " " + ALERT_INFO + " | " + syminfo.ticker + " | SESSION_RESET | " + currentSession
        string infoJson = '{"type":"INFO","pair":"' + syminfo.ticker + '","asset_class":"FX","primary":"SESSION_RESET","contributing":"","permission":"N/A","execution":{"max_risk":"NONE","max_trades":0,"adds":"DISABLED"},"context":{"direction":"none","score":0,"criteria":0,"entry":"N/A","vol_state":"' + atrState + '","mtf":0,"rsi":0,"session":"' + currentSession + '","playbook":"NONE","regime":"' + alertRegimeClean + '","risk_state":"' + alertRiskClean + '"}}'
        alert(infoHeader + "\n" + infoJson, alert.freq_once_per_bar)

// ============================================================================
// INSTITUTIONAL ALERT TAXONOMY (v2.5.0)
// ============================================================================
//
// 4-EMOJI STANDARD:
//   Green circle  ARMED     ‚Äî Execution allowed. Glance and move on.
//   Yellow circle CANDIDATE ‚Äî Quality present, permission missing. Watchlist.
//   Red circle    BLOCKED   ‚Äî Explicit veto. Ignore completely.
//   White circle  INFO      ‚Äî Context only. No action required.
//
// AUTHORITY STACK (Regime > Risk > UTCC):
//   Layer 1: Regime (ATR state + session) ‚Äî can force BLOCKED
//   Layer 2: Risk Governor (from Command Centre) ‚Äî can downgrade, never upgrade
//   Layer 3: UTCC Criteria ‚Äî contributes evidence, lowest authority
//
// REASON-CODE TAXONOMY:
//   R-series: Regime (R-EXPANSION, R-COMPRESSION, R-CHAOS, R-TRANSITION, R-OFFSESSION)
//   K-series: Risk (K-NORMAL, K-REDUCED, K-LOCKED)
//   U-series: UTCC (U-TREND-WEAK, U-MTF-MISALIGN, U-VOL-LOW, U-NEWS-RISK, U-SCORE-XX)
//
// SCAN LINE FORMAT:
//   [emoji] TYPE | PAIR | PRIMARY_REASON | RISK_STATE | U-SCORE-XX
//
// JSON PAYLOAD FIELDS:
//   type, pair, asset_class, primary, contributing, permission,
//   execution {max_risk, max_trades, adds}, context {direction, score,
//   criteria, entry, vol_state, mtf, rsi, session, playbook, regime, risk_state}
//
// ============================================================================
// ============================================================================
// DAY 3 TESTING NOTES & NEW FEATURES + BUG FIXES
// ============================================================================
// 
// BUGS FIXED:
// ‚úÖ BUG #1: Score always showing 100/100
//    - CAUSE: Base score of 50 points was too generous
//    - FIX: Changed base from 50 to 0, rebalanced weights:
//      * Trend: 30‚Üí40 points
//      * Volatility: 20‚Üí30 points  
//      * Momentum: 15‚Üí20 points
//      * Risk: 10‚Üí5 points (placeholder)
//      * Price Action: 3‚Üí5 points (placeholder)
//    - RESULT: Scores now properly range from 0-100 based on setup quality
//
// ‚úÖ BUG #2: Context row stuck at "NY | ‚Äï | ‚Äï"
//    - CAUSE: Using "var" for display variables = only set once on first bar
//    - FIX: Removed "var" from sessionText, timerText, spreadText, contextText
//    - RESULT: Context row now updates correctly every bar
//
// NEW IN DAY 4:
// ‚úÖ News Risk Detection (Time-Based)
//    - Detects London/NY opens (high-risk windows)
//    - Blocks trading during major volatility spikes
//    - Simple, reliable, zero external dependencies
//    - Updates criterion 5 with real risk detection
//
// ‚úÖ S/R Proximity System (Simple Distance Check)
//    - Measures distance to recent swing high/low
//    - Displays in ATR units (scale-independent)
//    - Warns when too close (<0.5 ATR)
//    - New section in Standard/Full mode
//
// ‚úÖ Entry Zone Analysis (EMA Pullback + RSI Bonus)
//    - Primary: Distance from Fast/Mid EMA
//    - Zones: HOT (0.3 ATR) / OPTIMAL (0.5) / ACCEPTABLE (1.0) / EXTENDED
//    - Bonus: RSI momentum confirmation (0-2 points)
//    - Total entry score: 0-7 points
//    - New section in Standard/Full mode
//
// ‚úÖ Enhanced Scoring System
//    - Risk score now includes: Daily position + Session quality + News risk
//    - Price action score now includes: S/R proximity + Entry zone quality
//    - More accurate overall 0-100 score
//
// DISPLAY MODE ROW COUNTS (UPDATED DAY 4):
//
// Minimal (2 rows):
//   - Pair/TF
//   - Status + Score
//
// Compact (11 rows) - PRIMARY TRADING:
//   - Pair/TF
//   - Status + Score
//   - Score breakdown (6 rows)
//   - 5 Criteria checklist (5 rows)
//   - Verdict
//   - Context row
//
// Standard (36 rows) - ACTIVE TRADING:
//   - [All Compact items]
//   - Score Breakdown (6 rows)
//   - Volatility Analysis (3 rows)
//   - Risk Management (4 rows)
//   - Trend Details (4 rows)
//   - S/R Proximity (4 rows) ‚Üê NEW DAY 4
//   - Entry Zone Analysis (5 rows) ‚Üê NEW DAY 4
//
// Full (46 rows) - DEEP ANALYSIS:
//   - [All Standard items]
//   - Momentum/RSI (6 rows)
//   - Price Action (3 rows)
//
// DAY 4 TESTING CHECKLIST:
// 1. Test news risk detection during London/NY opens
// 2. Verify criterion 5 shows "HIGH RISK" during risk periods
// 3. Check S/R proximity displays correct ATR distances
// 4. Verify entry zone shows correct quality (HOT/OPTIMAL/etc)
// 5. Test entry score calculation (base + RSI bonus)
// 6. Verify score breakdown reflects new components
// 7. Test on multiple pairs and timeframes
// 8. Verify Standard mode shows all new sections
//
// ============================================================================
