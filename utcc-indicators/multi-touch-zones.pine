//@version=6
indicator("Pro S/R Zones - Enhanced Multi-Touch", shorttitle="ProZones_V2", overlay=true, max_lines_count=500, max_labels_count=100, max_boxes_count=200)

//========================
// CORE INPUTS
//========================
grpA = "Core Settings"
tfOpt = input.string("4H", "Chart Timeframe", options = ["15m", "1H", "4H", "1D"], group=grpA)
lookX = input.int(2000, "Lookback (bars)", minval=500, maxval=5000, group=grpA)
sens = input.int(75, "Sensitivity (0..100)", minval=0, maxval=100, group=grpA)
wickMode = input.bool(true, "Touch mode: Wick-based", group=grpA)

grpDisp = "Display Filter"
drawMode = input.string("ATR window", "Filter Mode", options = ["None","ATR window","Percent window","Nearest N"], group=grpDisp)
winATR = input.float(4.0, "ATR Window Ã—", minval=0.5, step=0.5, group=grpDisp)
winPct = input.float(0.04, "% Window", minval=0.001, step=0.001, group=grpDisp)
nearN = input.int(15, "Nearest N zones", minval=1, maxval=80, group=grpDisp)

grpCaps = "Memory Caps"
maxKept = input.int(160, "Max zones in memory", minval=50, maxval=300, group=grpCaps)
maxDraw = input.int(50, "Max zones drawn", minval=5, maxval=100, group=grpCaps)
minTouches = input.int(3, "Min touches to display", minval=2, maxval=10, group=grpCaps)

grpClamp = "Zone Width Control"
useClamp = input.bool(true, "Enable width clamping", group=grpClamp)
clATRMax = input.float(0.8, "Max half-width ATRÃ—", minval=0.2, step=0.1, group=grpClamp)
clPctMax = input.float(0.0025, "Max half-width %", minval=0.0001, step=0.0001, group=grpClamp)
mergeATR = input.float(1.5, "Max merge span ATRÃ—", minval=0.5, step=0.5, group=grpClamp)
maxMergePass = input.int(3, "Max merge iterations", minval=1, maxval=5, group=grpClamp)

grpForex = "Forex Enhancements"
useRoundSnap = input.bool(true, "Snap to round numbers", group=grpForex)
snapStrength = input.float(1.5, "Snap strength (pips)", minval=0.5, step=0.5, group=grpForex)
spreadTol = input.float(0.5, "Spread tolerance (pips)", minval=0, step=0.1, group=grpForex)
useSession = input.bool(true, "Highlight session pivots", group=grpForex)
useAge = input.bool(true, "Apply age decay", group=grpForex)
ageHalfLife = input.int(800, "Age half-life (bars)", minval=100, maxval=2000, group=grpForex)

grpAdvanced = "Advanced Features"
trackRejections = input.bool(true, "Track rejections", group=grpAdvanced)
trackBreaks = input.bool(true, "Detect break-retest", group=grpAdvanced)
useVolWeight = input.bool(true, "Volume weighting", group=grpAdvanced)

grpScore = "Scoring Weights"
wEntry = input.float(1.00, "Entry weight", minval=0, step=0.1, group=grpScore)
wBoundary = input.float(0.40, "Boundary weight", minval=0, step=0.1, group=grpScore)
wPass = input.float(0.60, "Pass-through weight", minval=0, step=0.1, group=grpScore)
wPeak = input.float(0.50, "Peak weight", minval=0, step=0.1, group=grpScore)
wReject = input.float(0.80, "Rejection weight", minval=0, step=0.1, group=grpScore)
wVol = input.float(0.30, "Volume weight", minval=0, step=0.1, group=grpScore)

grpVis = "Visual Styling"
asBox = input.bool(true, "Draw as boxes", group=grpVis)
colFill = input.color(color.new(#2962FF, 85), "Fill color", group=grpVis)
colBrd = input.color(#2962FF, "Border color", group=grpVis)
colSession = input.color(color.new(color.yellow, 70), "Session highlight", group=grpVis)
colBroken = input.color(color.new(color.red, 85), "Broken zone fill", group=grpVis)
hiNearest = input.bool(true, "Highlight nearest", group=grpVis)
hiWidth = input.int(3, "Nearest width", minval=1, maxval=6, group=grpVis)
showLabels = input.bool(true, "Show info labels", group=grpVis)

grpAlr = "Alert Settings"
alEnter = input.bool(true, "Enter zone", group=grpAlr)
alExit = input.bool(true, "Exit zone", group=grpAlr)
alBoundary = input.bool(true, "Boundary touch", group=grpAlr)
alReject = input.bool(true, "Rejection detected", group=grpAlr)
alBreak = input.bool(true, "Zone broken", group=grpAlr)

dbgOn = input.bool(true, "Show debug panel", group="Debug")

//========================
// PERFORMANCE OPTIMIZATIONS - Calculate once per bar
//========================
atr14 = ta.atr(14)
lowestLow = ta.lowest(low, 10)
highestHigh = ta.highest(high, 10)

//========================
// HELPER FUNCTIONS
//========================
tf15m = "15"
tf1h = "60"
tf4h = "240"
tf1d = "D"
tfRun = tfOpt=="15m" ? tf15m : tfOpt=="1H" ? tf1h : tfOpt=="4H" ? tf4h : tf1d

f_clamp(x, lo, hi) => math.max(lo, math.min(hi, x))

f_get_f(a, i) => (i >= 0 and i < array.size(a)) ? array.get(a, i) : na
f_get_i(a, i) => (i >= 0 and i < array.size(a)) ? array.get(a, i) : 0
f_get_b(a, i) => (i >= 0 and i < array.size(a)) ? array.get(a, i) : false

f_kSwingATR_auto() => 0.20 + (100 - sens) * (0.30/100.0)
f_kATR_tol_auto() => 0.25 + (100 - sens) * (0.35/100.0)

f_tol(kATR, kPct, kTick, _atr) =>
    _spread = spreadTol * syminfo.mintick * 10
    math.max(kATR*_atr, kPct*close, kTick*syminfo.mintick) + _spread

f_snap_to_round(_p) =>
    if not useRoundSnap
        _p
    else
        _pipSize = syminfo.mintick * 10
        _snapDist = snapStrength * _pipSize
        _whole = math.floor(_p / (100 * _pipSize)) * (100 * _pipSize)
        _levels = array.from(_whole, _whole + 25*_pipSize, _whole + 50*_pipSize, _whole + 75*_pipSize, _whole + 100*_pipSize)
        float _snapped = _p
        float _minDist = _snapDist + 1
        for _lvl in _levels
            _d = math.abs(_p - _lvl)
            if _d < _minDist and _d <= _snapDist
                _snapped := _lvl
                _minDist := _d
        _snapped

f_pivotHi_confirmed(_l, _r, _kSwing, _atr, _lowest) =>
    _ph = ta.pivothigh(high, _l, _r)
    _amp = not na(_ph) ? (_ph - _lowest) : 0.0
    _min = math.max(_kSwing * _atr, 0.001*close, 2*syminfo.mintick)
    not na(_ph) and _amp >= _min ? _ph : na

f_pivotLo_confirmed(_l, _r, _kSwing, _atr, _highest) =>
    _pl = ta.pivotlow(low, _l, _r)
    _amp = not na(_pl) ? (_highest - _pl) : 0.0
    _min = math.max(_kSwing * _atr, 0.001*close, 2*syminfo.mintick)
    not na(_pl) and _amp >= _min ? _pl : na

f_htf_pivots(_tf, _l, _r, _kSwing) =>
    _ph = request.security(syminfo.tickerid, _tf, f_pivotHi_confirmed(_l, _r, _kSwing, atr14[_r], lowestLow[_r])[_r], gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_on)
    _pl = request.security(syminfo.tickerid, _tf, f_pivotLo_confirmed(_l, _r, _kSwing, atr14[_r], highestHigh[_r])[_r], gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_on)
    [_ph, _pl]

f_is_session_pivot() =>
    if not useSession
        false
    else
        _h = hour(time, syminfo.timezone)
        _h == 0 or _h == 8 or _h == 13

f_clamp_width(_lo, _hi, _atr) =>
    if not useClamp
        [_lo, _hi]
    else
        _half = (_hi - _lo) * 0.5
        _cap = math.min(clATRMax * _atr, clPctMax * close)
        if _half > _cap
            _mid = (_lo + _hi) * 0.5
            [_mid - _cap, _mid + _cap]
        else
            [_lo, _hi]

//========================
// HTF DATA STREAMS
//========================
kSwingATR = f_kSwingATR_auto()
kATRtol = f_kATR_tol_auto()
tolTF = request.security(syminfo.tickerid, tfRun, f_tol(kATRtol, 0.001, 2, atr14), gaps=barmerge.gaps_off)

[ph3, pl3] = f_htf_pivots(tfRun, 3, 3, kSwingATR)
[ph4, pl4] = f_htf_pivots(tfRun, 4, 4, kSwingATR)
[ph6, pl6] = f_htf_pivots(tfRun, 6, 6, kSwingATR)

// Pre-calculate isNew checks
isNewPH3 = not na(ph3) and na(ph3[1])
isNewPH4 = not na(ph4) and na(ph4[1])
isNewPH6 = not na(ph6) and na(ph6[1])
isNewPL3 = not na(pl3) and na(pl3[1])
isNewPL4 = not na(pl4) and na(pl4[1])
isNewPL6 = not na(pl6) and na(pl6[1])

newPH = isNewPH3 or isNewPH4 or isNewPH6
newPL = isNewPL3 or isNewPL4 or isNewPL6
lastPH = nz(isNewPH3 ? ph3 : isNewPH4 ? ph4 : isNewPH6 ? ph6 : na)
lastPL = nz(isNewPL3 ? pl3 : isNewPL4 ? pl4 : isNewPL6 ? pl6 : na)
isSessionPivot = f_is_session_pivot()

//========================
// ZONE STORAGE
//========================
var arrLo = array.new_float()
var arrHi = array.new_float()
var arrTch = array.new_int()
var arrFirst = array.new_int()
var arrLast = array.new_int()
var arrIn = array.new_bool()
var arrEntR = array.new_float()
var arrBndR = array.new_float()
var arrPasR = array.new_float()
var arrPkR = array.new_float()
var arrScore = array.new_float()
var arrReject = array.new_int()
var arrBroken = array.new_bool()
var arrFlipped = array.new_bool()
var arrSession = array.new_bool()
var arrVol = array.new_float()
var arrLastReject = array.new_int()

f_n() => array.size(arrLo)

f_mid(i) => (i >= 0 and i < f_n()) ? (f_get_f(arrLo, i) + f_get_f(arrHi, i)) * 0.5 : close

f_overlap(aLo, aHi, bLo, bHi) => (aLo <= bHi) and (bLo <= aHi)

decay = math.pow(0.5, 1.0 / math.max(10, lookX))

//========================
// ADD OR EXPAND ZONES
//========================
f_add_or_expand(_p, _ts, _tol, _isSess) =>
    if not na(_p)
        _pSnap = f_snap_to_round(_p)
        _h = math.max(_tol, syminfo.mintick)
        _sLo = _pSnap - _h
        _sHi = _pSnap + _h
        [loC, hiC] = f_clamp_width(_sLo, _sHi, atr14)
        _sLo := loC
        _sHi := hiC
        
        _idx = -1
        _n = f_n()
        for i = 0 to _n - 1
            if f_overlap(f_get_f(arrLo, i), f_get_f(arrHi, i), _sLo, _sHi)
                _idx := i
                break
        
        if _idx >= 0
            loU = math.min(f_get_f(arrLo, _idx), _sLo)
            hiU = math.max(f_get_f(arrHi, _idx), _sHi)
            [loM, hiM] = f_clamp_width(loU, hiU, atr14)
            array.set(arrLo, _idx, loM)
            array.set(arrHi, _idx, hiM)
            array.set(arrTch, _idx, f_get_i(arrTch, _idx) + 1)
            if f_get_i(arrFirst, _idx) == 0
                array.set(arrFirst, _idx, _ts)
            array.set(arrLast, _idx, _ts)
            if _isSess
                array.set(arrSession, _idx, true)
            if useVolWeight
                array.set(arrVol, _idx, f_get_f(arrVol, _idx) + volume)
        else
            array.push(arrLo, _sLo)
            array.push(arrHi, _sHi)
            array.push(arrTch, 1)
            array.push(arrFirst, _ts)
            array.push(arrLast, _ts)
            array.push(arrIn, false)
            array.push(arrEntR, 0.0)
            array.push(arrBndR, 0.0)
            array.push(arrPasR, 0.0)
            array.push(arrPkR, 0.0)
            array.push(arrScore, 0.0)
            array.push(arrReject, 0)
            array.push(arrBroken, false)
            array.push(arrFlipped, false)
            array.push(arrSession, _isSess)
            array.push(arrVol, volume)
            array.push(arrLastReject, 0)

if newPH
    f_add_or_expand(lastPH, time, tolTF, isSessionPivot)
if newPL
    f_add_or_expand(lastPL, time, tolTF, isSessionPivot)

//========================
// OPTIMIZED MERGE
//========================
f_merge_capped() =>
    _passes = 0
    _changed = true
    while _changed and _passes < maxMergePass
        _changed := false
        _passes += 1
        _n = f_n()
        if _n > 1
            i = 0
            while i < _n - 1
                j = i + 1
                merged = false
                while j < _n
                    aLo = f_get_f(arrLo, i)
                    aHi = f_get_f(arrHi, i)
                    bLo = f_get_f(arrLo, j)
                    bHi = f_get_f(arrHi, j)
                    if not na(aLo) and not na(aHi) and not na(bLo) and not na(bHi) and f_overlap(aLo, aHi, bLo, bHi)
                        loU = math.min(aLo, bLo)
                        hiU = math.max(aHi, bHi)
                        allow = (hiU - loU) <= (mergeATR * atr14)
                        if allow
                            [loM, hiM] = f_clamp_width(loU, hiU, atr14)
                            array.set(arrLo, i, loM)
                            array.set(arrHi, i, hiM)
                            array.set(arrTch, i, f_get_i(arrTch, i) + f_get_i(arrTch, j))
                            array.set(arrFirst, i, math.min(f_get_i(arrFirst, i), f_get_i(arrFirst, j)))
                            array.set(arrLast, i, math.max(f_get_i(arrLast, i), f_get_i(arrLast, j)))
                            array.set(arrIn, i, f_get_b(arrIn, i) or f_get_b(arrIn, j))
                            array.set(arrEntR, i, f_get_f(arrEntR, i) + f_get_f(arrEntR, j))
                            array.set(arrBndR, i, f_get_f(arrBndR, i) + f_get_f(arrBndR, j))
                            array.set(arrPasR, i, f_get_f(arrPasR, i) + f_get_f(arrPasR, j))
                            array.set(arrPkR, i, f_get_f(arrPkR, i) + f_get_f(arrPkR, j))
                            array.set(arrReject, i, f_get_i(arrReject, i) + f_get_i(arrReject, j))
                            array.set(arrSession, i, f_get_b(arrSession, i) or f_get_b(arrSession, j))
                            array.set(arrVol, i, f_get_f(arrVol, i) + f_get_f(arrVol, j))
                            array.set(arrBroken, i, f_get_b(arrBroken, i) or f_get_b(arrBroken, j))
                            
                            array.remove(arrLo, j)
                            array.remove(arrHi, j)
                            array.remove(arrTch, j)
                            array.remove(arrFirst, j)
                            array.remove(arrLast, j)
                            array.remove(arrIn, j)
                            array.remove(arrEntR, j)
                            array.remove(arrBndR, j)
                            array.remove(arrPasR, j)
                            array.remove(arrPkR, j)
                            array.remove(arrScore, j)
                            array.remove(arrReject, j)
                            array.remove(arrBroken, j)
                            array.remove(arrFlipped, j)
                            array.remove(arrSession, j)
                            array.remove(arrVol, j)
                            array.remove(arrLastReject, j)
                            
                            _n -= 1
                            _changed := true
                            merged := true
                        else
                            j += 1
                    else
                        j += 1
                if not merged
                    i += 1
    _passes

_merges = f_merge_capped()

if useClamp
    for i = 0 to f_n() - 1
        _lo = f_get_f(arrLo, i)
        _hi = f_get_f(arrHi, i)
        if not na(_lo) and not na(_hi)
            [_lo2, _hi2] = f_clamp_width(_lo, _hi, atr14)
            if _lo2 != _lo or _hi2 != _hi
                array.set(arrLo, i, _lo2)
                array.set(arrHi, i, _hi2)

//========================
// MEMORY MANAGEMENT
//========================
f_prune_cap(_cap) =>
    _rem = 0
    while f_n() > _cap
        _idx = f_n() - 1
        array.remove(arrLo, _idx)
        array.remove(arrHi, _idx)
        array.remove(arrTch, _idx)
        array.remove(arrFirst, _idx)
        array.remove(arrLast, _idx)
        array.remove(arrIn, _idx)
        array.remove(arrEntR, _idx)
        array.remove(arrBndR, _idx)
        array.remove(arrPasR, _idx)
        array.remove(arrPkR, _idx)
        array.remove(arrScore, _idx)
        array.remove(arrReject, _idx)
        array.remove(arrBroken, _idx)
        array.remove(arrFlipped, _idx)
        array.remove(arrSession, _idx)
        array.remove(arrVol, _idx)
        array.remove(arrLastReject, _idx)
        _rem += 1
    _rem

_pruned = f_prune_cap(maxKept)

//========================
// INTEREST TRACKING
//========================
f_inside(_lo, _hi, _tol) =>
    if wickMode
        not (high < _lo - _tol or low > _hi + _tol)
    else
        close >= _lo - _tol and close <= _hi + _tol

f_boundary(_lo, _hi, _tol, _inside) =>
    _t = false
    if not _inside
        if wickMode
            _t := ((low > _hi) and (low - _hi <= _tol)) or ((high < _lo) and (_lo - high <= _tol))
        else
            _t := (math.abs(close - _hi) <= _tol) or (math.abs(close - _lo) <= _tol)
    _t

f_rejection(_lo, _hi, _inNow, _inPrev) =>
    _rej = false
    if trackRejections and _inPrev
        if wickMode
            _wickTouch = (low <= _hi and high >= _lo)
            _closedOut = close < _lo or close > _hi
            _rej := _wickTouch and _closedOut
        else
            _rej := not _inNow
    _rej

f_break_detect(_lo, _hi, _inNow, _wasAbove, _wasBelow) =>
    _broke = false
    _flip = false
    if trackBreaks
        _nowAbove = close > _hi
        _nowBelow = close < _lo
        if _wasBelow and _nowAbove
            _broke := true
            _flip := true
        if _wasAbove and _nowBelow
            _broke := true
            _flip := true
    [_broke, _flip]

var anyEnter = false
var anyExit = false
var anyBnd = false
var anyReject = false
var anyBreak = false

f_interest_and_events() =>
    _anyE = false
    _anyX = false
    _anyB = false
    _anyR = false
    _anyBr = false
    _n = f_n()
    if _n == 0
        [_anyE, _anyX, _anyB, _anyR, _anyBr]
    else
        _tolNow = tolTF
        for i = 0 to _n - 1
            _lo = f_get_f(arrLo, i)
            _hi = f_get_f(arrHi, i)
            if not na(_lo) and not na(_hi)
                _inPrev = f_get_b(arrIn, i)
                _inNow = f_inside(_lo, _hi, _tolNow)
                
                _ent = (not _inPrev) and _inNow
                _exi = _inPrev and (not _inNow)
                _bnd = f_boundary(_lo, _hi, _tolNow, _inNow)
                _pass = (low <= _lo and high >= _hi)
                _rej = f_rejection(_lo, _hi, _inNow, _inPrev)
                
                _peak = false
                if newPH and not na(lastPH) and lastPH >= _lo and lastPH <= _hi
                    _peak := true
                if newPL and not na(lastPL) and lastPL >= _lo and lastPL <= _hi
                    _peak := true
                
                _wasAbove = close[1] > _hi
                _wasBelow = close[1] < _lo
                [_broke, _flip] = f_break_detect(_lo, _hi, _inNow, _wasAbove, _wasBelow)
                
                if _rej
                    array.set(arrReject, i, f_get_i(arrReject, i) + 1)
                    array.set(arrLastReject, i, bar_index)
                if _broke
                    array.set(arrBroken, i, true)
                if _flip
                    array.set(arrFlipped, i, true)
                
                array.set(arrEntR, i, f_get_f(arrEntR, i) * decay + (_ent ? 1 : 0))
                array.set(arrBndR, i, f_get_f(arrBndR, i) * decay + (_bnd ? 1 : 0))
                array.set(arrPasR, i, f_get_f(arrPasR, i) * decay + (_pass ? 1 : 0))
                array.set(arrPkR, i, f_get_f(arrPkR, i) * decay + (_peak ? 1 : 0))
                
                _ageWeight = 1.0
                if useAge
                    _barAge = (time - f_get_i(arrFirst, i)) / (timeframe.multiplier * 60000)
                    _ageWeight := math.exp(-_barAge / ageHalfLife)
                
                _volWeight = useVolWeight ? math.log10(1 + f_get_f(arrVol, i) / volume) : 1.0
                
                _sc = wEntry * f_get_f(arrEntR, i) + wPass * f_get_f(arrPasR, i) + wBoundary * f_get_f(arrBndR, i) + wPeak * f_get_f(arrPkR, i) + wReject * f_get_i(arrReject, i) + wVol * _volWeight
                _sc *= _ageWeight
                
                array.set(arrScore, i, _sc)
                
                if _ent or _bnd
                    array.set(arrTch, i, f_get_i(arrTch, i) + 1)
                
                array.set(arrIn, i, _inNow)
                
                _anyE := _anyE or _ent
                _anyX := _anyX or _exi
                _anyB := _anyB or _bnd
                _anyR := _anyR or _rej
                _anyBr := _anyBr or _broke
        [_anyE, _anyX, _anyB, _anyR, _anyBr]

[resE, resX, resB, resR, resBr] = f_interest_and_events()
anyEnter := resE
anyExit := resX
anyBnd := resB
anyReject := resR
anyBreak := resBr

//========================
// ZONE SELECTION
//========================
atrNow = atr14
distThr = drawMode == "ATR window" ? winATR * atrNow : drawMode == "Percent window" ? winPct * close : 10e9

idxs = array.new_int()
_nZones = f_n()

for i = 0 to _nZones - 1
    _ok = true
    if f_get_i(arrTch, i) < minTouches
        _ok := false
    
    if _ok and (drawMode == "ATR window" or drawMode == "Percent window")
        _ok := math.abs(close - f_mid(i)) <= distThr
    
    if _ok or drawMode == "None" or drawMode == "Nearest N"
        array.push(idxs, i)

f_sort_by_score_desc(_a) =>
    _nA = array.size(_a)
    if _nA > 1
        for ai = 0 to _nA - 2
            swapped = false
            for bi = 0 to _nA - ai - 2
                idxB = array.get(_a, bi)
                idxNext = array.get(_a, bi + 1)
                scB = f_get_f(arrScore, idxB)
                scNext = f_get_f(arrScore, idxNext)
                if (not na(scNext)) and (na(scB) or scNext > scB)
                    array.set(_a, bi, idxNext)
                    array.set(_a, bi + 1, idxB)
                    swapped := true
            if not swapped
                break

f_sort_by_dist_asc(_a) =>
    _n = array.size(_a)
    if _n > 1
        for ai = 0 to _n - 2
            swapped = false
            for bi = 0 to _n - ai - 2
                idxB = array.get(_a, bi)
                idxNext = array.get(_a, bi + 1)
                di = math.abs(close - f_mid(idxB))
                dn = math.abs(close - f_mid(idxNext))
                if dn < di
                    array.set(_a, bi, idxNext)
                    array.set(_a, bi + 1, idxB)
                    swapped := true
            if not swapped
                break

if (drawMode == "ATR window" or drawMode == "Percent window") and array.size(idxs) == 0
    if _nZones > 0
        for i = 0 to _nZones - 1
            if f_get_i(arrTch, i) >= minTouches
                array.push(idxs, i)
        if array.size(idxs) > 1
            f_sort_by_dist_asc(idxs)
        while array.size(idxs) > nearN
            array.pop(idxs)
else
    if drawMode == "Nearest N"
        if array.size(idxs) > 1
            f_sort_by_dist_asc(idxs)
        while array.size(idxs) > nearN
            array.pop(idxs)
    else
        if array.size(idxs) > 1
            f_sort_by_score_desc(idxs)

targetN = int(8 * math.pow(1.05, sens))
targetN := f_clamp(targetN, 8, maxDraw)

while array.size(idxs) > maxDraw
    array.pop(idxs)

thrScore = 0.0
if array.size(idxs) > 0
    if array.size(idxs) > 1
        f_sort_by_score_desc(idxs)
    _k = math.min(array.size(idxs) - 1, targetN - 1)
    _idxK = array.get(idxs, _k)
    thrScore := f_get_f(arrScore, _idxK)

//========================
// DRAWING ENGINE
//========================
var box[] bx = array.new_box()
var line[] lt = array.new_line()
var line[] lb = array.new_line()
var label[] lbl = array.new_label()

f_ensure_objs(n) =>
    if asBox
        while array.size(bx) < n
            array.push(bx, box.new(bar_index, close, bar_index, close, xloc=xloc.bar_index, border_color=colBrd, bgcolor=colFill))
        while array.size(bx) > n
            box.delete(array.pop(bx))
    else
        while array.size(lt) < n
            _t = line.new(bar_index, close, bar_index, close, xloc=xloc.bar_index, extend=extend.right, color=colBrd, width=1)
            _b = line.new(bar_index, close, bar_index, close, xloc=xloc.bar_index, extend=extend.right, color=colBrd, width=1)
            array.push(lt, _t)
            array.push(lb, _b)
        while array.size(lt) > n
            line.delete(array.pop(lt))
            line.delete(array.pop(lb))
    
    if showLabels
        while array.size(lbl) < n
            array.push(lbl, label.new(bar_index, close, "", xloc=xloc.bar_index, style=label.style_label_left, size=size.tiny))
        while array.size(lbl) > n
            label.delete(array.pop(lbl))
    else
        while array.size(lbl) > 0
            label.delete(array.pop(lbl))

cnt = array.size(idxs)
if cnt == 0
    if asBox
        while array.size(bx) > 0
            box.delete(array.pop(bx))
    else
        while array.size(lt) > 0
            line.delete(array.pop(lt))
        while array.size(lb) > 0
            line.delete(array.pop(lb))
    while array.size(lbl) > 0
        label.delete(array.pop(lbl))
else
    f_ensure_objs(cnt)
    leftX = math.max(0, bar_index - lookX)
    rightX = bar_index + 50
    
    float nearestIdx = na
    if hiNearest and cnt > 0
        int best = -1
        float bd = 1e10
        for j = 0 to cnt - 1
            ii = array.get(idxs, j)
            d = math.abs(close - f_mid(ii))
            if best == -1 or d < bd
                best := j
                bd := d
        nearestIdx := float(best)
    
    for j = 0 to cnt - 1
        iIdx = array.get(idxs, j)
        if iIdx >= 0 and iIdx < _nZones
            _lo = f_get_f(arrLo, iIdx)
            _hi = f_get_f(arrHi, iIdx)
            _broken = f_get_b(arrBroken, iIdx)
            _session = f_get_b(arrSession, iIdx)
            _rejects = f_get_i(arrReject, iIdx)
            _touches = f_get_i(arrTch, iIdx)
            _score = f_get_f(arrScore, iIdx)
            
            if not na(_lo) and not na(_hi)
                _fillCol = _broken ? colBroken : (_session ? colSession : colFill)
                _bordCol = _broken ? color.red : (_session ? color.yellow : colBrd)
                _width = (hiNearest and j == int(nearestIdx)) ? hiWidth : 1
                
                if asBox
                    b = array.get(bx, j)
                    box.set_left(b, leftX)
                    box.set_right(b, rightX)
                    box.set_top(b, _hi)
                    box.set_bottom(b, _lo)
                    box.set_bgcolor(b, _fillCol)
                    box.set_border_color(b, _bordCol)
                    box.set_border_width(b, _width)
                else
                    tL = array.get(lt, j)
                    bL = array.get(lb, j)
                    line.set_x1(tL, leftX)
                    line.set_x2(tL, rightX)
                    line.set_y1(tL, _hi)
                    line.set_y2(tL, _hi)
                    line.set_x1(bL, leftX)
                    line.set_x2(bL, rightX)
                    line.set_y1(bL, _lo)
                    line.set_y2(bL, _lo)
                    line.set_width(tL, _width)
                    line.set_width(bL, _width)
                    line.set_color(tL, _bordCol)
                    line.set_color(bL, _bordCol)
                
                if showLabels and j < array.size(lbl)
                    _lab = array.get(lbl, j)
                    _mid = f_mid(iIdx)
                    _txt = str.format("T:{0} R:{1} S:{2}", _touches, _rejects, str.tostring(_score, format.mintick))
                    label.set_xy(_lab, rightX + 2, _mid)
                    label.set_text(_lab, _txt)
                    label.set_color(_lab, _fillCol)
                    label.set_textcolor(_lab, color.white)

//========================
// ALERT SYSTEM - FIXED
//========================
inTopList(i) =>
    _has = false
    if array.size(idxs) > 0  // Added bounds check
        for j = 0 to array.size(idxs) - 1
            if array.get(idxs, j) == i
                _has := true
                break
    _has

if anyEnter or anyExit or anyBnd or anyReject or anyBreak
    for i = 0 to _nZones - 1
        if f_get_f(arrScore, i) >= thrScore and inTopList(i)
            _lo = f_get_f(arrLo, i)
            _hi = f_get_f(arrHi, i)
            if not na(_lo) and not na(_hi)
                _mid = f_mid(i)
                _touches = f_get_i(arrTch, i)
                _rejects = f_get_i(arrReject, i)
                _broken = f_get_b(arrBroken, i)
                
                _msg = str.format("Zone [{0}..{1}] Mid:{2} | T:{3} R:{4} Score:{5}", str.tostring(_lo, format.mintick), str.tostring(_hi, format.mintick), str.tostring(_mid, format.mintick), _touches, _rejects, str.tostring(f_get_f(arrScore, i), format.mintick))
                
                if anyEnter
                    alert("ðŸŸ¢ ENTER " + _msg, alert.freq_once_per_bar)
                if anyExit
                    alert("ðŸ”´ EXIT " + _msg, alert.freq_once_per_bar)
                if anyBnd
                    alert("ðŸŸ¡ BOUNDARY " + _msg, alert.freq_once_per_bar)
                if anyReject
                    alert("âš¡ REJECTION " + _msg, alert.freq_once_per_bar)
                if anyBreak and _broken
                    alert("ðŸ’¥ BREAK " + _msg, alert.freq_once_per_bar)

alertcondition(alEnter and anyEnter, title="Enter Zone", message="Price entered S/R zone")
alertcondition(alExit and anyExit, title="Exit Zone", message="Price exited S/R zone")
alertcondition(alBoundary and anyBnd, title="Boundary Touch", message="Price touched zone boundary")
alertcondition(alReject and anyReject, title="Rejection", message="Price rejected from zone")
alertcondition(alBreak and anyBreak, title="Zone Break", message="Zone broken - potential flip")

//========================
// DEBUG PANEL
//========================
var table T = na
if dbgOn
    if na(T)
        T := table.new(position.top_right, 2, 12, border_width=1, frame_color=color.new(color.white, 80))
    
    table.cell(T, 0, 0, "PRO S/R ZONES â€¢ " + tfOpt, text_color=color.white, bgcolor=color.new(color.blue, 60))
    table.cell(T, 1, 0, "Sens: " + str.tostring(sens))
    
    table.cell(T, 0, 1, "Zones (Mem/Draw)", text_color=color.white, bgcolor=color.new(color.gray, 80))
    cellText = str.tostring(_nZones) + "/" + str.tostring(maxKept) + " â€¢ " + str.tostring(cnt) + "/" + str.tostring(maxDraw)
    table.cell(T, 1, 1, cellText)
    
    table.cell(T, 0, 2, "Score Threshold", text_color=color.white, bgcolor=color.new(color.gray, 80))
    table.cell(T, 1, 2, str.tostring(thrScore, "#.##"))
    
    table.cell(T, 0, 3, "Width Clamp", text_color=color.white, bgcolor=color.new(color.gray, 80))
    clampText = useClamp ? "ATRÃ—" + str.tostring(clATRMax) + " / " + str.tostring(clPctMax*100, "#.##") + "%" : "OFF"
    table.cell(T, 1, 3, clampText)
    
    table.cell(T, 0, 4, "Merge Limit", text_color=color.white, bgcolor=color.new(color.gray, 80))
    mergeText = "ATRÃ—" + str.tostring(mergeATR) + " / " + str.tostring(_merges) + " passes"
    table.cell(T, 1, 4, mergeText)
    
    table.cell(T, 0, 5, "Display Filter", text_color=color.white, bgcolor=color.new(color.gray, 80))
    dfText = drawMode == "ATR window" ? "ATRÃ—" + str.tostring(winATR) : drawMode == "Percent window" ? str.tostring(winPct*100, "#.##") + "%" : drawMode == "Nearest N" ? "N=" + str.tostring(nearN) : "None"
    table.cell(T, 1, 5, dfText)
    
    table.cell(T, 0, 6, "Min Touches", text_color=color.white, bgcolor=color.new(color.gray, 80))
    table.cell(T, 1, 6, str.tostring(minTouches))
    
    table.cell(T, 0, 7, "Features", text_color=color.white, bgcolor=color.new(color.gray, 80))
    featText = (useRoundSnap ? "R" : "-") + "/" + (useSession ? "S" : "-") + "/" + (trackRejections ? "J" : "-") + "/" + (trackBreaks ? "B" : "-")
    table.cell(T, 1, 7, featText, tooltip="Round/Session/Rejection/Break")
    
    table.cell(T, 0, 8, "Events (Bar)", text_color=color.white, bgcolor=color.new(color.gray, 80))
    eventsText = (anyEnter ? "E" : "-") + "/" + (anyExit ? "X" : "-") + "/" + (anyBnd ? "B" : "-") + "/" + (anyReject ? "R" : "-") + "/" + (anyBreak ? "K" : "-")
    table.cell(T, 1, 8, eventsText)
    
    table.cell(T, 0, 9, "Age Decay", text_color=color.white, bgcolor=color.new(color.gray, 80))
    ageText = useAge ? "Î»=" + str.tostring(ageHalfLife) : "OFF"
    table.cell(T, 1, 9, ageText)
    
    table.cell(T, 0, 10, "Volume Weight", text_color=color.white, bgcolor=color.new(color.gray, 80))
    volText = useVolWeight ? "ON Ã—" + str.tostring(wVol, "#.#") : "OFF"
    table.cell(T, 1, 10, volText)
    
    table.cell(T, 0, 11, "Performance", text_color=color.white, bgcolor=color.new(color.gray, 80))
    perfText = "Prune:" + str.tostring(_pruned) + " Merge:" + str.tostring(_merges)
    table.cell(T, 1, 11, perfText)
